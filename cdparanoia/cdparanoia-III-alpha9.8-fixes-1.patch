Submitted By: Jim Gifford (jim at linuxfromscratch dot org)
Date: 2006-07-20
Initial Package Version: alpha9.8
Origin: Various
Description: Fixes for different architectures
	     Fixes for GCC 3.4
	     Missing Includes
	     Fixes for 2.6.15

diff -Naur cdparanoia-III-alpha9.8.orig/configure cdparanoia-III-alpha9.8/configure
--- cdparanoia-III-alpha9.8.orig/configure	2000-04-15 08:13:01.000000000 -0700
+++ cdparanoia-III-alpha9.8/configure	2006-07-19 15:21:35.000000000 -0700
@@ -46,6 +46,16 @@
 infodir='${prefix}/info'
 mandir='${prefix}/man'
 
+# NLS nuisances.
+# Only set these to C if already set.  These must not be set unconditionally
+# because not all systems understand e.g. LANG=C (notably SCO).
+# Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
+# Non-C LC_CTYPE values break the ctype check.
+if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
+if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
+if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
+if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
+
 # Initialize some other variables.
 subdirs=
 MFLAGS= MAKEFLAGS=
@@ -434,16 +444,6 @@
   esac
 done
 
-# NLS nuisances.
-# Only set these to C if already set.  These must not be set unconditionally
-# because not all systems understand e.g. LANG=C (notably SCO).
-# Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
-# Non-C LC_CTYPE values break the ctype check.
-if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
-if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
-if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
-if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
-
 # confdefs.h avoids OS command line length limits that DEFS can exceed.
 rm -rf conftest* confdefs.h
 # AIX cpp loses on an empty file, so make sure it contains at least a newline.
@@ -892,10 +892,10 @@
 	case $host in 
 	i?86-*-linux*)
 		DEBUG="-g -Wall -fsigned-char"
-		OPT="-O20 -ffast-math -fsigned-char -finline-functions";;
+		OPT="-ffast-math -fsigned-char -finline-functions";;
 	*)
 		DEBUG="-g -Wall -fsigned-char"
-		OPT="-O20 -fsigned-char";;
+		OPT="-fsigned-char";;
         esac
 fi
 
@@ -1084,9 +1084,9 @@
 fi
 
 
-CFLAGS=""
+# CFLAGS=""
 
-TYPESIZES="" 
+# TYPESIZES="" 
 
 echo $ac_n "checking size of short""... $ac_c" 1>&6
 echo "configure:1093: checking size of short" >&5
diff -Naur cdparanoia-III-alpha9.8.orig/configure.guess cdparanoia-III-alpha9.8/configure.guess
--- cdparanoia-III-alpha9.8.orig/configure.guess	1999-08-15 14:52:30.000000000 -0700
+++ cdparanoia-III-alpha9.8/configure.guess	2006-07-19 15:25:27.000000000 -0700
@@ -1,7 +1,10 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 93, 94, 95, 1996 Free Software Foundation, Inc.
-#
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+timestamp='2006-01-02'
+
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
@@ -14,81 +17,326 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
-# Written by Per Bothner <bothner@cygnus.com>.
-# The master version of this file is at the FSF in /home/gd/gnu/lib.
+
+# Originally written by Per Bothner <per@bothner.com>.
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
 #
 # This script attempts to guess a canonical system name similar to
 # config.sub.  If it succeeds, it prints the system name on stdout, and
 # exits with 0.  Otherwise, it exits with 1.
 #
 # The plan is that this can be called by configure scripts if you
-# don't specify an explicit system type (host/target name).
-#
-# Only a few systems have been added to this list; please add others
-# (but try to keep the structure clean).
-#
+# don't specify an explicit build system type.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+trap 'exit 1' 1 2 15
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+set_cc_for_build='
+trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
+trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
+: ${TMPDIR=/tmp} ;
+ { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+ { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
+dummy=$tmp/dummy ;
+tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo "int x;" > $dummy.c ;
+	for c in cc gcc c89 c99 ; do
+	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
+	     CC_FOR_BUILD="$c"; break ;
+	  fi ;
+	done ;
+	if test x"$CC_FOR_BUILD" = x ; then
+	  CC_FOR_BUILD=no_compiler_found ;
+	fi
+	;;
+ ,,*)   CC_FOR_BUILD=$CC ;;
+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+esac ; set_cc_for_build= ;'
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
-# (ghazi@noc.rutgers.edu 8/24/94.)
+# (ghazi@noc.rutgers.edu 1994-08-24)
 if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
 UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
 UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
-trap 'rm -f dummy.c dummy.o dummy; exit 1' 1 2 15
-
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	sysctl="sysctl -n hw.machine_arch"
+	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	case "${UNAME_MACHINE_ARCH}" in
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently, or will in the future.
+	case "${UNAME_MACHINE_ARCH}" in
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		eval $set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep __ELF__ >/dev/null
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+	        os=netbsd
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case "${UNAME_VERSION}" in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	echo "${machine}-${os}${release}"
+	exit ;;
+    *:OpenBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	exit ;;
+    *:SolidBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerppc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    *:MirBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
     alpha:OSF1:*:*)
+	case $UNAME_RELEASE in
+	*4.0)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		;;
+	*5.*)
+	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case "$ALPHA_CPU_TYPE" in
+	    "EV4 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE="alphaev5" ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE="alphaev56" ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE="alphapca56" ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE="alphapca57" ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE="alphaev6" ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE="alphaev67" ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE="alphaev69" ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE="alphaev7" ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE="alphaev79" ;;
+	esac
+	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo alpha-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//'`
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit ;;
+    Alpha\ *:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# Should we change UNAME_MACHINE based on the output of uname instead
+	# of the specific Alpha model?
+	echo alpha-pc-interix
+	exit ;;
     21064:Windows_NT:50:3)
 	echo alpha-dec-winnt3.5
-	exit 0 ;;
+	exit ;;
     Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-cbm-sysv4
-	exit 0;;
-    amiga:NetBSD:*:*)
-      echo m68k-cbm-netbsd${UNAME_RELEASE}
-      exit 0 ;;
+	echo m68k-unknown-sysv4
+	exit ;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-amigaos
+	exit ;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-morphos
+	exit ;;
+    *:OS/390:*:*)
+	echo i370-ibm-openedition
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+        echo powerpc-ibm-os400
+	exit ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
-	exit 0;;
-    Pyramid*:OSx*:*:*)
+	exit ;;
+    arm:riscos:*:*|arm:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit ;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
 	if test "`(/bin/universe) 2>/dev/null`" = att ; then
 		echo pyramid-pyramid-sysv3
 	else
 		echo pyramid-pyramid-bsd
 	fi
-	exit 0 ;;
-    sun4*:SunOS:5.*:*)
+	exit ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) echo sparc-icl-nx7; exit ;;
+	esac ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     i86pc:SunOS:5.*:*)
-	echo i386-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
 	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     sun4*:SunOS:*:*)
 	case "`/usr/bin/arch -k`" in
 	    Series*|S4*)
@@ -97,81 +345,169 @@
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
 	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
-	exit 0 ;;
+	exit ;;
     sun3*:SunOS:*:*)
 	echo m68k-sun-sunos${UNAME_RELEASE}
-	exit 0 ;;
-    atari*:NetBSD:*:*)
-	echo m68k-atari-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sun3*:NetBSD:*:*)
-	echo m68k-sun-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:NetBSD:*:*)
-	echo m68k-apple-netbsd${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	case "`/bin/arch`" in
+	    sun3)
+		echo m68k-sun-sunos${UNAME_RELEASE}
+		;;
+	    sun4)
+		echo sparc-sun-sunos${UNAME_RELEASE}
+		;;
+	esac
+	exit ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit ;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+        exit ;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+        echo m68k-milan-mint${UNAME_RELEASE}
+        exit ;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+        echo m68k-hades-mint${UNAME_RELEASE}
+        exit ;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+        echo m68k-unknown-mint${UNAME_RELEASE}
+        exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten${UNAME_RELEASE}
+	exit ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit ;;
     RISC*:ULTRIX:*:*)
 	echo mips-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     VAX*:ULTRIX*:*:*)
 	echo vax-dec-ultrix${UNAME_RELEASE}
-	exit 0 ;;
-    mips:*:4*:UMIPS)
-	echo mips-mips-riscos4sysv
-	exit 0 ;;
-    mips:*:5*:RISCos)
+	exit ;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	echo clipper-intergraph-clix${UNAME_RELEASE}
+	exit ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
 	echo mips-mips-riscos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
+    Motorola:PowerMAX_OS:*:*)
+	echo powerpc-motorola-powermax
+	exit ;;
+    Motorola:*:4.3:PL8-*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	echo powerpc-harris-powermax
+	exit ;;
     Night_Hawk:Power_UNIX:*:*)
 	echo powerpc-harris-powerunix
-	exit 0 ;;
+	exit ;;
     m88k:CX/UX:7*:*)
 	echo m88k-harris-cxux7
-	exit 0 ;;
+	exit ;;
     m88k:*:4*:R4*)
 	echo m88k-motorola-sysv4
-	exit 0 ;;
+	exit ;;
     m88k:*:3*:R3*)
 	echo m88k-motorola-sysv3
-	exit 0 ;;
+	exit ;;
     AViiON:dgux:*:*)
         # DG/UX returns AViiON for all architectures
         UNAME_PROCESSOR=`/usr/bin/uname -p`
-        if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88100 ] ; then
-	if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx \
-	     -o ${TARGET_BINARY_INTERFACE}x = x ] ; then
+	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	then
+	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
+	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    then
 		echo m88k-dg-dgux${UNAME_RELEASE}
-	else
+	    else
 		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	    fi
+	else
+	    echo i586-dg-dgux${UNAME_RELEASE}
 	fi
-        else echo i586-dg-dgux${UNAME_RELEASE}
-        fi
- 	exit 0 ;;
+ 	exit ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
 	echo m88k-dolphin-sysv3
-	exit 0 ;;
+	exit ;;
     M88*:*:R3*:*)
 	# Delta 88k system running SVR3
 	echo m88k-motorola-sysv3
-	exit 0 ;;
+	exit ;;
     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
 	echo m88k-tektronix-sysv3
-	exit 0 ;;
+	exit ;;
     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
 	echo m68k-tektronix-bsd
-	exit 0 ;;
+	exit ;;
     *:IRIX*:*:*)
 	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
-	exit 0 ;;
-   ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
-	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
-	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
-    i[34]86:AIX:*:*)
+	exit ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
 	echo i386-ibm-aix
-	exit 0 ;;
+	exit ;;
+    ia64:AIX:*:*)
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	exit ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		sed 's/^		//' << EOF >dummy.c
+		eval $set_cc_for_build
+		sed 's/^		//' << EOF >$dummy.c
 		#include <sys/systemcfg.h>
 
 		main()
@@ -182,17 +518,21 @@
 			exit(0);
 			}
 EOF
-		${CC-cc} dummy.c -o dummy && ./dummy && rm dummy.c dummy && exit 0
-		rm -f dummy.c dummy
-		echo rs6000-ibm-aix3.2.5
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
 		echo rs6000-ibm-aix3.2.4
 	else
 		echo rs6000-ibm-aix3.2
 	fi
-	exit 0 ;;
-    *:AIX:*:4)
-	if /usr/sbin/lsattr -EHl proc0 | grep POWER >/dev/null 2>&1; then
+	exit ;;
+    *:AIX:*:[45])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
@@ -200,43 +540,120 @@
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
-		IBM_REV=4.${UNAME_RELEASE}
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
-	exit 0 ;;
+	exit ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
-	exit 0 ;;
+	exit ;;
     ibmrt:4.4BSD:*|romp-ibm:BSD:*)
 	echo romp-ibm-bsd4.4
-	exit 0 ;;
-    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC NetBSD and
-	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to 
-	exit 0 ;;                           # report: romp-ibm BSD 4.3
+	exit ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit ;;                             # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
 	echo rs6000-bull-bosx
-	exit 0 ;;
+	exit ;;
     DPX/2?00:B.O.S.:*:*)
 	echo m68k-bull-sysv3
-	exit 0 ;;
+	exit ;;
     9000/[34]??:4.3bsd:1.*:*)
 	echo m68k-hp-bsd
-	exit 0 ;;
+	exit ;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
 	echo m68k-hp-bsd4.4
-	exit 0 ;;
-    9000/[3478]??:HP-UX:*:*)
+	exit ;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	case "${UNAME_MACHINE}" in
 	    9000/31? )            HP_ARCH=m68000 ;;
 	    9000/[34]?? )         HP_ARCH=m68k ;;
-	    9000/7?? | 9000/8?[679] ) HP_ARCH=hppa1.1 ;;
-	    9000/8?? )            HP_ARCH=hppa1.0 ;;
+	    9000/[678][0-9][0-9])
+		if [ -x /usr/bin/getconf ]; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+                    case "${sc_cpu_version}" in
+                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+                      532)                      # CPU_PA_RISC2_0
+                        case "${sc_kernel_bits}" in
+                          32) HP_ARCH="hppa2.0n" ;;
+                          64) HP_ARCH="hppa2.0w" ;;
+			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+                        esac ;;
+                    esac
+		fi
+		if [ "${HP_ARCH}" = "" ]; then
+		    eval $set_cc_for_build
+		    sed 's/^              //' << EOF >$dummy.c
+
+              #define _HPUX_SOURCE
+              #include <stdlib.h>
+              #include <unistd.h>
+
+              int main ()
+              {
+              #if defined(_SC_KERNEL_BITS)
+                  long bits = sysconf(_SC_KERNEL_BITS);
+              #endif
+                  long cpu  = sysconf (_SC_CPU_VERSION);
+
+                  switch (cpu)
+              	{
+              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+              	case CPU_PA_RISC2_0:
+              #if defined(_SC_KERNEL_BITS)
+              	    switch (bits)
+              		{
+              		case 64: puts ("hppa2.0w"); break;
+              		case 32: puts ("hppa2.0n"); break;
+              		default: puts ("hppa2.0"); break;
+              		} break;
+              #else  /* !defined(_SC_KERNEL_BITS) */
+              	    puts ("hppa2.0"); break;
+              #endif
+              	default: puts ("hppa1.0"); break;
+              	}
+                  exit (0);
+              }
+EOF
+		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
 	esac
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	if [ ${HP_ARCH} = "hppa2.0w" ]
+	then
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep __LP64__ >/dev/null
+	    then
+		HP_ARCH="hppa2.0w"
+	    else
+		HP_ARCH="hppa64"
+	    fi
+	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit 0 ;;
+	exit ;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux${HPUX_REV}
+	exit ;;
     3050*:HI-UX:*:*)
-	sed 's/^	//' << EOF >dummy.c
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
 	#include <unistd.h>
 	int
 	main ()
@@ -261,186 +678,455 @@
 	  exit (0);
 	}
 EOF
-	${CC-cc} dummy.c -o dummy && ./dummy && rm dummy.c dummy && exit 0
-	rm -f dummy.c dummy
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+		{ echo "$SYSTEM_NAME"; exit; }
 	echo unknown-hitachi-hiuxwe2
-	exit 0 ;;
+	exit ;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
 	echo hppa1.1-hp-bsd
-	exit 0 ;;
+	exit ;;
     9000/8??:4.3bsd:*:*)
 	echo hppa1.0-hp-bsd
-	exit 0 ;;
+	exit ;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	echo hppa1.0-hp-mpeix
+	exit ;;
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
 	echo hppa1.1-hp-osf
-	exit 0 ;;
+	exit ;;
     hp8??:OSF1:*:*)
 	echo hppa1.0-hp-osf
-	exit 0 ;;
+	exit ;;
+    i*86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit ;;
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
-	exit 0 ;;
+	exit ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
-        exit 0 ;;
+        exit ;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-        exit 0 ;;
+        exit ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
 	echo c34-convex-bsd
-        exit 0 ;;
+        exit ;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
 	echo c38-convex-bsd
-        exit 0 ;;
+        exit ;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
 	echo c4-convex-bsd
-        exit 0 ;;
-    CRAY*X-MP:*:*:*)
-	echo xmp-cray-unicos
-        exit 0 ;;
+        exit ;;
     CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos${UNAME_RELEASE}
-	exit 0 ;;
-    CRAY*C90:*:*:*)
-	echo c90-cray-unicos${UNAME_RELEASE}
-	exit 0 ;;
-    CRAY-2:*:*:*)
-	echo cray2-cray-unicos
-        exit 0 ;;
-    hp3[0-9][05]:NetBSD:*:*)
-	echo m68k-hp-netbsd${UNAME_RELEASE}
-	exit 0 ;;
-    i[34]86:BSD/386:*:* | *:BSD/OS:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*T3E:*:*:*)
+	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*SV1:*:*:*)
+	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    *:UNICOS/mp:*:*)
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+        exit ;;
+    5000:UNIX_System_V:4.*:*)
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
     *:FreeBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit 0 ;;
-    *:NetBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-	exit 0 ;;
+	case ${UNAME_MACHINE} in
+	    pc98)
+		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    *)
+		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	esac
+	exit ;;
     i*:CYGWIN*:*)
-	echo i386-unknown-cygwin32
-	exit 0 ;;
+	echo ${UNAME_MACHINE}-pc-cygwin
+	exit ;;
+    i*:MINGW*:*)
+	echo ${UNAME_MACHINE}-pc-mingw32
+	exit ;;
+    i*:windows32*:*)
+    	# uname -m includes "-pc" on this system.
+    	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
+    i*:PW*:*)
+	echo ${UNAME_MACHINE}-pc-pw32
+	exit ;;
+    x86:Interix*:[345]*)
+	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
+	exit ;;
+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+	echo i${UNAME_MACHINE}-pc-mks
+	exit ;;
+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+	# UNAME_MACHINE based on the output of uname instead of i386?
+	echo i586-pc-interix
+	exit ;;
+    i*:UWIN*:*)
+	echo ${UNAME_MACHINE}-pc-uwin
+	exit ;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	echo x86_64-unknown-cygwin
+	exit ;;
     p*:CYGWIN*:*)
-	echo powerpcle-unknown-cygwin32
-	exit 0 ;;
+	echo powerpcle-unknown-cygwin
+	exit ;;
     prep*:SunOS:5.*:*)
 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+	exit ;;
     *:GNU:*:*)
-	echo `echo ${UNAME_MACHINE}|sed -e 's,/.*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
-	exit 0 ;;
-    *:Linux:*:*)
+	# the GNU system
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	exit ;;
+    i*86:Minix:*:*)
+	echo ${UNAME_MACHINE}-pc-minix
+	exit ;;
+    arm*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit ;;
+    crisv32:Linux:*:*)
+	echo crisv32-axis-linux-gnu
+	exit ;;
+    frv:Linux:*:*)
+    	echo frv-unknown-linux-gnu
+	exit ;;
+    ia64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m32r*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    m68*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    mips:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips
+	#undef mipsel
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mipsel
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '/^CPU/{s: ::g;p;}'`"
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
+    mips64:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips64
+	#undef mips64el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mips64el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips64
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '/^CPU/{s: ::g;p;}'`"
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	;;
+    or32:Linux:*:*)
+	echo or32-unknown-linux-gnu
+	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-gnu
+	exit ;;
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-gnu
+	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+        esac
+	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
+	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit ;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
+	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
+	  *)    echo hppa-unknown-linux-gnu ;;
+	esac
+	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-gnu
+	exit ;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	echo ${UNAME_MACHINE}-ibm-linux
+	exit ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sh*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit ;;
+    vax:Linux:*:*)
+	echo ${UNAME_MACHINE}-dec-linux-gnu
+	exit ;;
+    x86_64:Linux:*:*)
+	echo x86_64-unknown-linux-gnu
+	exit ;;
+    i*86:Linux:*:*)
 	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us.
-	ld_help_string=`ld --help 2>&1`
-	if echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: elf_i[3456]86"; then
-	  echo "${UNAME_MACHINE}-unknown-linux" ; exit 0
-	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i[3456]86linux"; then
-	  echo "${UNAME_MACHINE}-unknown-linuxaout" ; exit 0
-	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: i[3456]86coff"; then
-	  echo "${UNAME_MACHINE}-unknown-linuxcoff" ; exit 0
-	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: m68kelf"; then
-	  echo "${UNAME_MACHINE}-unknown-linux" ; exit 0
-	elif echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations: m68klinux"; then
-	  echo "${UNAME_MACHINE}-unknown-linuxaout" ; exit 0
-	elif test "${UNAME_MACHINE}" = "alpha" ; then
-	  echo alpha-unknown-linux ; exit 0
-	else
-	  # Either a pre-BFD a.out linker (linuxoldld) or one that does not give us
-	  # useful --help.  Gcc wants to distinguish between linuxoldld and linuxaout.
-	  test ! -d /usr/lib/ldscripts/. \
-	    && echo "${UNAME_MACHINE}-unknown-linuxoldld" && exit 0
-	  # Determine whether the default compiler is a.out or elf
-	  cat >dummy.c <<EOF
-main(argc, argv)
-int argc;
-char *argv[];
-{
-#ifdef __ELF__
-  printf ("%s-unknown-linux\n", argv[1]);
-#else
-  printf ("%s-unknown-linuxaout\n", argv[1]);
-#endif
-  return 0;
-}
+	# first see if it will tell us. cd to the root directory to prevent
+	# problems with other programs or directories called `ld' in the path.
+	# Set LC_ALL=C to ensure ld outputs messages in English.
+	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
+			 | sed -ne '/supported targets:/!d
+				    s/[ 	][ 	]*/ /g
+				    s/.*supported targets: *//
+				    s/ .*//
+				    p'`
+        case "$ld_supported_targets" in
+	  elf32-i386)
+		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
+		;;
+	  a.out-i386-linux)
+		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
+		exit ;;
+	  coff-i386)
+		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
+		exit ;;
+	  "")
+		# Either a pre-BFD a.out linker (linux-gnuoldld) or
+		# one that does not give us useful --help.
+		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
+		exit ;;
+	esac
+	# Determine whether the default compiler is a.out or elf
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <features.h>
+	#ifdef __ELF__
+	# ifdef __GLIBC__
+	#  if __GLIBC__ >= 2
+	LIBC=gnu
+	#  else
+	LIBC=gnulibc1
+	#  endif
+	# else
+	LIBC=gnulibc1
+	# endif
+	#else
+	#if defined(__INTEL_COMPILER) || defined(__PGI)
+	LIBC=gnu
+	#else
+	LIBC=gnuaout
+	#endif
+	#endif
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
 EOF
-	  ${CC-cc} dummy.c -o dummy 2>/dev/null && ./dummy "${UNAME_MACHINE}" && rm dummy.c dummy && exit 0
-	  rm -f dummy.c dummy
-	fi ;;
-# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions
-# are messed up and put the nodename in both sysname and nodename.
-    i[34]86:DYNIX/ptx:4*:*)
+	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '/^LIBC/{s: ::g;p;}'`"
+	test x"${LIBC}" != x && {
+		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+		exit
+	}
+	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
+	;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
 	echo i386-sequent-sysv4
-	exit 0 ;;
-    i[34]86:*:4.*:* | i[34]86:SYSTEM_V:4.*:*)
+	exit ;;
+    i*86:UNIX_SV:4.2MP:2.*)
+        # Unixware is an offshoot of SVR4, but it has its own version
+        # number series starting with 2...
+        # I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+        # Use sysv4.2uw... so that sysv4* matches it.
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	exit ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo ${UNAME_MACHINE}-pc-os2-emx
+	exit ;;
+    i*86:XTS-300:*:STOP)
+	echo ${UNAME_MACHINE}-unknown-stop
+	exit ;;
+    i*86:atheos:*:*)
+	echo ${UNAME_MACHINE}-unknown-atheos
+	exit ;;
+    i*86:syllable:*:*)
+	echo ${UNAME_MACHINE}-pc-syllable
+	exit ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    i*86:*DOS:*:*)
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	exit ;;
+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_RELEASE}
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
 	else
-		echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
 	fi
-	exit 0 ;;
-    i[34]86:*:3.2:*)
+	exit ;;
+    i*86:*:5:[678]*)
+    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	case `/bin/uname -X | grep "^Machine"` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	exit ;;
+    i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo ${UNAME_MACHINE}-unknown-isc$UNAME_REL
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
-		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
-		(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
-		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
 			&& UNAME_MACHINE=i586
-		echo ${UNAME_MACHINE}-unknown-sco$UNAME_REL
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
 	else
-		echo ${UNAME_MACHINE}-unknown-sysv32
+		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
-	exit 0 ;;
+	exit ;;
+    pc:*:*:*)
+	# Left here for compatibility:
+        # uname -m prints for DJGPP always 'pc', but it prints nothing about
+        # the processor, so we play safe by assuming i386.
+	echo i386-pc-msdosdjgpp
+        exit ;;
     Intel:Mach:3*:*)
-	echo i386-unknown-mach3
-	exit 0 ;;
+	echo i386-pc-mach3
+	exit ;;
     paragon:*:*:*)
 	echo i860-intel-osf1
-	exit 0 ;;
+	exit ;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
 	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
 	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
 	fi
-	exit 0 ;;
+	exit ;;
     mini*:CTIX:SYS*5:*)
 	# "miniframe"
 	echo m68010-convergent-sysv
-	exit 0 ;;
-    M680[234]0:*:R3V[567]*:*)
-	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[34]??:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0)
-        uname -p 2>/dev/null | grep 86 >/dev/null \
-          && echo i486-ncr-sysv4.3 && exit 0 ;;
+	exit ;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	echo m68k-convergent-sysv
+	exit ;;
+    M680?0:D-NIX:5.3:*)
+	echo m68k-diab-dnix
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        uname -p 2>/dev/null | grep 86 >/dev/null \
-          && echo i486-ncr-sysv4 && exit 0 ;;
-    m680[234]0:LynxOS:2.[23]*:*)
-	echo m68k-lynx-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+          && { echo i486-ncr-sysv4; exit; } ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
-	exit 0 ;;
-    i[34]86:LynxOS:2.[23]*:*)
-	echo i386-lynx-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    TSUNAMI:LynxOS:2.[23]*:*)
-	echo sparc-lynx-lynxos${UNAME_RELEASE}
-	exit 0 ;;
-    rs6000:LynxOS:2.[23]*:*)
-	echo rs6000-lynx-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	exit ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    rs6000:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
     RM*:SINIX-*:*:*)
 	echo mips-sni-sysv4
-	exit 0 ;;
+	exit ;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
@@ -448,23 +1134,156 @@
 	else
 		echo ns32k-sni-sysv
 	fi
-	exit 0 ;;
+	exit ;;
+    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                      # says <Richard.M.Bartel@ccMail.Census.GOV>
+        echo i586-unisys-sysv4
+        exit ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
+    *:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo hppa1.1-stratus-vos
+	exit ;;
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
-	exit 0 ;;
-    R3000:*System_V*:*:*)
+	exit ;;
+    news*:NEWS-OS:6*:*)
+	echo mips-sony-newsos6
+	exit ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
 	        echo mips-nec-sysv${UNAME_RELEASE}
 	else
 	        echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
-        exit 0 ;;
+        exit ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-6:SUPER-UX:*:*)
+	echo sx6-nec-superux${UNAME_RELEASE}
+	exit ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Rhapsody:*:*)
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Darwin:*:*)
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+	exit ;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = "x86"; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+	exit ;;
+    *:QNX:*:4*)
+	echo i386-pc-qnx
+	exit ;;
+    NSE-?:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSR-?:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit ;;
+    BS2000:POSIX*:*:*)
+	echo bs2000-siemens-sysv
+	exit ;;
+    DS/*:UNIX_System_V:*:*)
+	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	exit ;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test "$cputype" = "386"; then
+	    UNAME_MACHINE=i386
+	else
+	    UNAME_MACHINE="$cputype"
+	fi
+	echo ${UNAME_MACHINE}-unknown-plan9
+	exit ;;
+    *:TOPS-10:*:*)
+	echo pdp10-unknown-tops10
+	exit ;;
+    *:TENEX:*:*)
+	echo pdp10-unknown-tenex
+	exit ;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	echo pdp10-dec-tops20
+	exit ;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	echo pdp10-xkl-tops20
+	exit ;;
+    *:TOPS-20:*:*)
+	echo pdp10-unknown-tops20
+	exit ;;
+    *:ITS:*:*)
+	echo pdp10-unknown-its
+	exit ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
+    *:DragonFly:*:*)
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    *:*VMS:*:*)
+    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "${UNAME_MACHINE}" in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+    i*86:rdos:*:*)
+	echo ${UNAME_MACHINE}-pc-rdos
+	exit ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
 #echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
 
-cat >dummy.c <<EOF
+eval $set_cc_for_build
+cat >$dummy.c <<EOF
 #ifdef _SEQUENT_
 # include <sys/types.h>
 # include <sys/utsname.h>
@@ -489,7 +1308,7 @@
 #endif
 
 #if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix"); exit (0);
+  printf ("arm-acorn-riscix\n"); exit (0);
 #endif
 
 #if defined (hp300) && !defined (hpux)
@@ -502,7 +1321,10 @@
 #endif
   int version;
   version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
-  printf ("%s-next-nextstep%s\n", __ARCHITECTURE__,  version==2 ? "2" : "3");
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
   exit (0);
 #endif
 
@@ -519,7 +1341,7 @@
 #endif
 
 #if defined (__386BSD__)
-  printf ("i386-unknown-bsd\n"); exit (0);
+  printf ("i386-pc-bsd\n"); exit (0);
 #endif
 
 #if defined (sequent)
@@ -547,11 +1369,24 @@
 #endif
 
 #if defined (vax)
-#if !defined (ultrix)
-  printf ("vax-dec-bsd\n"); exit (0);
-#else
-  printf ("vax-dec-ultrix\n"); exit (0);
-#endif
+# if !defined (ultrix)
+#  include <sys/param.h>
+#  if defined (BSD)
+#   if BSD == 43
+      printf ("vax-dec-bsd4.3\n"); exit (0);
+#   else
+#    if BSD == 199006
+      printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#    else
+      printf ("vax-dec-bsd\n"); exit (0);
+#    endif
+#   endif
+#  else
+    printf ("vax-dec-bsd\n"); exit (0);
+#  endif
+# else
+    printf ("vax-dec-ultrix\n"); exit (0);
+# endif
 #endif
 
 #if defined (alliant) && defined (i860)
@@ -562,12 +1397,12 @@
 }
 EOF
 
-${CC-cc} dummy.c -o dummy 2>/dev/null && ./dummy && rm dummy.c dummy && exit 0
-rm -f dummy.c dummy
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+	{ echo "$SYSTEM_NAME"; exit; }
 
 # Apollos put the system type in the environment.
 
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
 
 # Convex versions that predate uname can use getsysinfo(1)
 
@@ -576,25 +1411,69 @@
     case `getsysinfo -f cpu_type` in
     c1*)
 	echo c1-convex-bsd
-	exit 0 ;;
+	exit ;;
     c2*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-	exit 0 ;;
+	exit ;;
     c34*)
 	echo c34-convex-bsd
-	exit 0 ;;
+	exit ;;
     c38*)
 	echo c38-convex-bsd
-	exit 0 ;;
+	exit ;;
     c4*)
 	echo c4-convex-bsd
-	exit 0 ;;
+	exit ;;
     esac
 fi
 
-#echo '(Unable to guess system type)' 1>&2
+cat >&2 <<EOF
+$0: unable to guess system type
+
+This script, last modified $timestamp, has failed to recognize
+the operating system you are using. It is advised that you
+download the most up to date version of the config scripts from
+
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
+and
+  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
+
+If the version you run ($0) is already up to date, please
+send the following data and any information you think might be
+pertinent to <config-patches@gnu.org> in order to provide the needed
+information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = ${UNAME_MACHINE}
+UNAME_RELEASE = ${UNAME_RELEASE}
+UNAME_SYSTEM  = ${UNAME_SYSTEM}
+UNAME_VERSION = ${UNAME_VERSION}
+EOF
 
 exit 1
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff -Naur cdparanoia-III-alpha9.8.orig/configure.in cdparanoia-III-alpha9.8/configure.in
--- cdparanoia-III-alpha9.8.orig/configure.in	2000-03-25 23:33:22.000000000 -0800
+++ cdparanoia-III-alpha9.8/configure.in	2006-07-19 15:15:59.000000000 -0700
@@ -19,18 +19,18 @@
 	case $host in 
 	i?86-*-linux*)
 		DEBUG="-g -Wall -fsigned-char"
-		OPT="-O20 -ffast-math -fsigned-char -finline-functions";;
+		OPT="-ffast-math -fsigned-char -finline-functions";;
 	*)
 		DEBUG="-g -Wall -fsigned-char"
-		OPT="-O20 -fsigned-char";;
+		OPT="-fsigned-char";;
         esac
 fi
 
 AC_HEADER_STDC
 
-CFLAGS=""
+# CFLAGS=""
 
-TYPESIZES="" 
+# TYPESIZES="" 
 
 AC_CHECK_SIZEOF(short)
 AC_CHECK_SIZEOF(int)
diff -Naur cdparanoia-III-alpha9.8.orig/configure.sub cdparanoia-III-alpha9.8/configure.sub
--- cdparanoia-III-alpha9.8.orig/configure.sub	1999-08-15 14:52:30.000000000 -0700
+++ cdparanoia-III-alpha9.8/configure.sub	2006-07-19 15:25:32.000000000 -0700
@@ -1,9 +1,13 @@
 #! /bin/sh
-# Configuration validation subroutine script, version 1.1.
-#   Copyright (C) 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
+# Configuration validation subroutine script.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+timestamp='2006-01-02'
+
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can. 
+# can handle that machine.  It does not imply ALL GNU software can.
 #
 # This file is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -17,14 +21,18 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330,
-# Boston, MA 02111-1307, USA.
-
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+# 02110-1301, USA.
+#
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
+
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
@@ -41,32 +49,89 @@
 # The goal of this file is to map all the various variations of a given
 # machine specification into a single specification in the form:
 #	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
 # It is wrong to echo any other type of specification.
 
-if [ x$1 = x ]
-then
-	echo Configuration name missing. 1>&2
-	echo "Usage: $0 CPU-MFR-OPSYS" 1>&2
-	echo "or     $0 ALIAS" 1>&2
-	echo where ALIAS is a recognized configuration type. 1>&2
-	exit 1
-fi
+me=`echo "$0" | sed -e 's,.*/,,'`
 
-# First pass through any local machine types.
-case $1 in
-	*local*)
-		echo $1
-		exit 0
-		;;
-	*)
-	;;
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS
+       $0 [OPTION] ALIAS
+
+Canonicalize a configuration name.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help"
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo $1
+       exit ;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
 esac
 
-# Separate what the user gave into CPU-COMPANY and OS (if any).
-basic_machine=`echo $1 | sed 's/-[^-]*$//'`
-if [ $basic_machine != $1 ]
-then os=`echo $1 | sed 's/.*-/-/'`
-else os=; fi
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
+  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
+  storm-chaos* | os2-emx* | rtmk-nova*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
 
 ### Let's recognize common machines as not being operating systems so
 ### that things like config.sub decstation-3100 work.  We also
@@ -81,38 +146,72 @@
 	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
-	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp )
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple | -axis | -knuth | -cray)
 		os=
 		basic_machine=$1
 		;;
+	-sim | -cisco | -oki | -wec | -winbond)
+		os=
+		basic_machine=$1
+		;;
+	-scout)
+		;;
+	-wrs)
+		os=-vxworks
+		basic_machine=$1
+		;;
+	-chorusos*)
+		os=-chorusos
+		basic_machine=$1
+		;;
+ 	-chorusrdb)
+ 		os=-chorusrdb
+		basic_machine=$1
+ 		;;
 	-hiux*)
 		os=-hiuxwe2
 		;;
+	-sco6)
+		os=-sco5v6
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco5)
+		os=-sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
 	-sco4)
 		os=-sco3.2v4
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2.[4-9]*)
 		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco3.2v[4-9]*)
 		# Don't forget version if it is 3.2v4 or newer.
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-sco*)
 		os=-sco3.2v2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-udk*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-isc)
 		os=-isc2.2
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-clix*)
 		basic_machine=clipper-intergraph
 		;;
 	-isc*)
-		basic_machine=`echo $1 | sed -e 's/86-.*/86-unknown/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
 	-lynx*)
 		os=-lynxos
@@ -123,44 +222,180 @@
 	-windowsnt*)
 		os=`echo $os | sed -e 's/windowsnt/winnt/'`
 		;;
+	-psos*)
+		os=-psos
+		;;
+	-mint | -mint[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
 case $basic_machine in
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
-	tahoe | i[3456]86 | i860 | m68k | m68000 | m88k | ns32k | arm \
-		| arme[lb] | pyramid \
-		| tron | a29k | 580 | i960 | h8300 | hppa1.0 | hppa1.1 \
-		| alpha | we32k | ns16k | clipper | sparclite | i370 | sh \
-		| powerpc | powerpcle | sparc64 | 1750a | dsp16xx | mips64 | mipsel \
-		| pdp11 | mips64el | mips64orion | mips64orionel \
-		| sparc)
+	1750a | 580 \
+	| a29k \
+	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
+	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| am33_2.0 \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
+	| bfin \
+	| c4x | clipper \
+	| d10v | d30v | dlx | dsp16xx \
+	| fr30 | frv \
+	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| i370 | i860 | i960 | ia64 \
+	| ip2k | iq2000 \
+	| m32r | m32rle | m68000 | m68k | m88k | maxq | mb | microblaze | mcore \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
+	| mips16 \
+	| mips64 | mips64el \
+	| mips64vr | mips64vrel \
+	| mips64orion | mips64orionel \
+	| mips64vr4100 | mips64vr4100el \
+	| mips64vr4300 | mips64vr4300el \
+	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
+	| mipsisa32 | mipsisa32el \
+	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64sb1 | mipsisa64sb1el \
+	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipstx39 | mipstx39el \
+	| mn10200 | mn10300 \
+	| mt \
+	| msp430 \
+	| ns16k | ns32k \
+	| or32 \
+	| pdp10 | pdp11 | pj | pjl \
+	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| pyramid \
+	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| sh64 | sh64le \
+	| sparc | sparc64 | sparc64b | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b \
+	| strongarm \
+	| tahoe | thumb | tic4x | tic80 | tron \
+	| v850 | v850e \
+	| we32k \
+	| x86 | xscale | xscalee[bl] | xstormy16 | xtensa \
+	| z8k)
+		basic_machine=$basic_machine-unknown
+		;;
+	m32c)
 		basic_machine=$basic_machine-unknown
 		;;
+	m6811 | m68hc11 | m6812 | m68hc12)
+		# Motorola 68HC11/12.
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
+		;;
+	ms1)
+		basic_machine=mt-unknown
+		;;
+
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+	  basic_machine=$basic_machine-pc
+	  ;;
 	# Object if more than one company name word.
 	*-*-*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
 		;;
 	# Recognize the basic CPU types with company name.
-	vax-* | tahoe-* | i[3456]86-* | i860-* | m68k-* | m68000-* | m88k-* \
-	      | sparc-* | ns32k-* | fx80-* | arm-* | c[123]* \
-	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* | power-* \
-	      | none-* | 580-* | cray2-* | h8300-* | i960-* | xmp-* | ymp-* \
-	      | hppa1.0-* | hppa1.1-* | alpha-* | we32k-* | cydra-* | ns16k-* \
-	      | pn-* | np1-* | xps100-* | clipper-* | orion-* | sparclite-* \
-	      | pdp11-* | sh-* | powerpc-* | powerpcle-* | sparc64-* | mips64-* | mipsel-* \
-	      | mips64el-* | mips64orion-* | mips64orionel-*)
+	580-* \
+	| a29k-* \
+	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
+	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
+	| avr-* \
+	| bfin-* | bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
+	| clipper-* | craynv-* | cydra-* \
+	| d10v-* | d30v-* | dlx-* \
+	| elxsi-* \
+	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| h8300-* | h8500-* \
+	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| i*86-* | i860-* | i960-* | ia64-* \
+	| ip2k-* | iq2000-* \
+	| m32r-* | m32rle-* \
+	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
+	| mips16-* \
+	| mips64-* | mips64el-* \
+	| mips64vr-* | mips64vrel-* \
+	| mips64orion-* | mips64orionel-* \
+	| mips64vr4100-* | mips64vr4100el-* \
+	| mips64vr4300-* | mips64vr4300el-* \
+	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
+	| mipsisa32-* | mipsisa32el-* \
+	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64sb1-* | mipsisa64sb1el-* \
+	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| mt-* \
+	| msp430-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
+	| orion-* \
+	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| pyramid-* \
+	| romp-* | rs6000-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | shbe-* \
+	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
+	| tahoe-* | thumb-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tron-* \
+	| v850-* | v850e-* | vax-* \
+	| we32k-* \
+	| x86-* | x86_64-* | xps100-* | xscale-* | xscalee[bl]-* \
+	| xstormy16-* | xtensa-* \
+	| ymp-* \
+	| z8k-*)
+		;;
+	m32c-*)
 		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
+	386bsd)
+		basic_machine=i386-unknown
+		os=-bsd
+		;;
 	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
 		basic_machine=m68000-att
 		;;
 	3b*)
 		basic_machine=we32k-att
 		;;
+	a29khif)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+    	abacus)
+		basic_machine=abacus-unknown
+		;;
+	adobe68k)
+		basic_machine=m68010-adobe
+		os=-scout
+		;;
 	alliant | fx80)
 		basic_machine=fx80-alliant
 		;;
@@ -171,29 +406,47 @@
 		basic_machine=a29k-none
 		os=-bsd
 		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	amdahl)
 		basic_machine=580-amdahl
 		os=-sysv
 		;;
 	amiga | amiga-*)
-		basic_machine=m68k-cbm
+		basic_machine=m68k-unknown
 		;;
-	amigados)
-		basic_machine=m68k-cbm
-		os=-amigados
+	amigaos | amigados)
+		basic_machine=m68k-unknown
+		os=-amigaos
 		;;
 	amigaunix | amix)
-		basic_machine=m68k-cbm
+		basic_machine=m68k-unknown
 		os=-sysv4
 		;;
 	apollo68)
 		basic_machine=m68k-apollo
 		os=-sysv
 		;;
+	apollo68bsd)
+		basic_machine=m68k-apollo
+		os=-bsd
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
 	balance)
 		basic_machine=ns32k-sequent
 		os=-dynix
 		;;
+	c90)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
 	convex-c1)
 		basic_machine=c1-convex
 		os=-bsd
@@ -214,23 +467,45 @@
 		basic_machine=c38-convex
 		os=-bsd
 		;;
-	cray | ymp)
-		basic_machine=ymp-cray
+	cray | j90)
+		basic_machine=j90-cray
 		os=-unicos
 		;;
-	cray2)
-		basic_machine=cray2-cray
-		os=-unicos
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16c)
+		basic_machine=cr16c-unknown
+		os=-elf
 		;;
 	crds | unos)
 		basic_machine=m68k-crds
 		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
+	cris | cris-* | etrax*)
+		basic_machine=cris-axis
+		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
 	da30 | da30-*)
 		basic_machine=m68k-da30
 		;;
 	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
 		basic_machine=mips-dec
 		;;
+	decsystem10* | dec10*)
+		basic_machine=pdp10-dec
+		os=-tops10
+		;;
+	decsystem20* | dec20*)
+		basic_machine=pdp10-dec
+		os=-tops20
+		;;
 	delta | 3300 | motorola-3300 | motorola-delta \
 	      | 3300-motorola | delta-motorola)
 		basic_machine=m68k-motorola
@@ -239,6 +514,10 @@
 		basic_machine=m88k-motorola
 		os=-sysv3
 		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
 	dpx20 | dpx20-*)
 		basic_machine=rs6000-bull
 		os=-bosx
@@ -258,6 +537,10 @@
 	encore | umax | mmax)
 		basic_machine=ns32k-encore
 		;;
+	es1800 | OSE68k | ose68k | ose | OSE)
+		basic_machine=m68k-ericsson
+		os=-ose
+		;;
 	fx2800)
 		basic_machine=i860-alliant
 		;;
@@ -268,6 +551,10 @@
 		basic_machine=tron-gmicro
 		os=-sysv
 		;;
+	go32)
+		basic_machine=i386-pc
+		os=-go32
+		;;
 	h3050r* | hiux*)
 		basic_machine=hppa1.1-hitachi
 		os=-hiuxwe2
@@ -276,6 +563,14 @@
 		basic_machine=h8300-hitachi
 		os=-hms
 		;;
+	h8300xray)
+		basic_machine=h8300-hitachi
+		os=-xray
+		;;
+	h8500hms)
+		basic_machine=h8500-hitachi
+		os=-hms
+		;;
 	harris)
 		basic_machine=m88k-harris
 		os=-sysv3
@@ -291,39 +586,74 @@
 		basic_machine=m68k-hp
 		os=-hpux
 		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
 	hp9k2[0-9][0-9] | hp9k31[0-9])
 		basic_machine=m68000-hp
 		;;
 	hp9k3[2-9][0-9])
 		basic_machine=m68k-hp
 		;;
-	hp9k7[0-9][0-9] | hp7[0-9][0-9] | hp9k8[0-9]7 | hp8[0-9]7)
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
 		basic_machine=hppa1.1-hp
 		;;
 	hp9k8[0-9][0-9] | hp8[0-9][0-9])
 		basic_machine=hppa1.0-hp
 		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	hppaosf)
+		basic_machine=hppa1.1-hp
+		os=-osf
+		;;
+	hppro)
+		basic_machine=hppa1.1-hp
+		os=-proelf
+		;;
 	i370-ibm* | ibm*)
 		basic_machine=i370-ibm
-		os=-mvs
 		;;
 # I'm not sure what "Sysv32" means.  Should this be sysv3.2?
-	i[3456]86v32)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
+	i*86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv32
 		;;
-	i[3456]86v4*)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
+	i*86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv4
 		;;
-	i[3456]86v)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
+	i*86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv
 		;;
-	i[3456]86sol2)
-		basic_machine=`echo $1 | sed -e 's/86.*/86-unknown/'`
+	i*86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-solaris2
 		;;
+	i386mach)
+		basic_machine=i386-mach
+		os=-mach
+		;;
+	i386-vsta | vsta)
+		basic_machine=i386-unknown
+		os=-vsta
+		;;
 	iris | iris4d)
 		basic_machine=mips-sgi
 		case $os in
@@ -349,19 +679,54 @@
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
+	mingw32)
+		basic_machine=i386-pc
+		os=-mingw32
+		;;
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
+	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
+	monitor)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	morphos)
+		basic_machine=powerpc-unknown
+		os=-morphos
+		;;
+	msdos)
+		basic_machine=i386-pc
+		os=-msdos
+		;;
+	ms1-*)
+		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
+		;;
+	mvs)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
 		;;
+	netbsd386)
+		basic_machine=i386-unknown
+		os=-netbsd
+		;;
+	netwinder)
+		basic_machine=armv4l-rebel
+		os=-linux
+		;;
 	news | news700 | news800 | news900)
 		basic_machine=m68k-sony
 		os=-newsos
@@ -374,6 +739,10 @@
 		basic_machine=mips-sony
 		os=-newsos
 		;;
+	necv70)
+		basic_machine=v70-nec
+		os=-sysv
+		;;
 	next | m*-next )
 		basic_machine=m68k-next
 		case $os in
@@ -399,9 +768,39 @@
 		basic_machine=i960-intel
 		os=-nindy
 		;;
+	mon960)
+		basic_machine=i960-intel
+		os=-mon960
+		;;
+	nonstopux)
+		basic_machine=mips-compaq
+		os=-nonstopux
+		;;
 	np1)
 		basic_machine=np1-gould
 		;;
+	nsr-tandem)
+		basic_machine=nsr-tandem
+		;;
+	op50n-* | op60c-*)
+		basic_machine=hppa1.1-oki
+		os=-proelf
+		;;
+	openrisc | openrisc-*)
+		basic_machine=or32-unknown
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
+		;;
+	OSE68000 | ose68000)
+		basic_machine=m68000-ericsson
+		os=-ose
+		;;
+	os68k)
+		basic_machine=m68k-none
+		os=-os68k
+		;;
 	pa-hitachi)
 		basic_machine=hppa1.1-hitachi
 		os=-hiuxwe2
@@ -416,49 +815,105 @@
 	pbb)
 		basic_machine=m68k-tti
 		;;
-        pc532 | pc532-*)
+	pc532 | pc532-*)
 		basic_machine=ns32k-pc532
 		;;
-	pentium | p5 | p6)
-		# We don't have specific support for the Intel Pentium (p6) followon yet, so just call it a Pentium
-		basic_machine=i586-intel
+	pc98)
+		basic_machine=i386-pc
+		;;
+	pc98-*)
+		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium | p5 | k5 | k6 | nexgen | viac3)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | 6x86 | athlon | athlon_*)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2 | pentiumiii | pentium3)
+		basic_machine=i686-pc
+		;;
+	pentium4)
+		basic_machine=i786-pc
 		;;
-	pentium-* | p5-* | p6-*)
-		# We don't have specific support for the Intel Pentium (p6) followon yet, so just call it a Pentium
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
 		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	k5)
-		# We don't have specific support for AMD's K5 yet, so just call it a Pentium
-		basic_machine=i586-amd
-		;;
-	nexen)
-		# We don't have specific support for Nexgen yet, so just call it a Pentium
-		basic_machine=i586-nexgen
+	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pn)
 		basic_machine=pn-gould
 		;;
-	power)	basic_machine=rs6000-ibm
+	power)	basic_machine=power-ibm
 		;;
 	ppc)	basic_machine=powerpc-unknown
-	        ;;
+		;;
 	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ppcle | powerpclittle | ppc-le | powerpc-little)
 		basic_machine=powerpcle-unknown
-	        ;;
+		;;
 	ppcle-* | powerpclittle-*)
 		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
+	ppc64)	basic_machine=powerpc64-unknown
+		;;
+	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+		basic_machine=powerpc64le-unknown
+		;;
+	ppc64le-* | powerpc64little-*)
+		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	ps2)
 		basic_machine=i386-ibm
 		;;
+	pw32)
+		basic_machine=i586-unknown
+		os=-pw32
+		;;
+	rdos)
+		basic_machine=i386-pc
+		os=-rdos
+		;;
+	rom68k)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
 	rm[46]00)
 		basic_machine=mips-siemens
 		;;
 	rtpc | rtpc-*)
 		basic_machine=romp-ibm
 		;;
+	s390 | s390-*)
+		basic_machine=s390-ibm
+		;;
+	s390x | s390x-*)
+		basic_machine=s390x-ibm
+		;;
+	sa29200)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	sb1)
+		basic_machine=mipsisa64sb1-unknown
+		;;
+	sb1el)
+		basic_machine=mipsisa64sb1el-unknown
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
 	sequent)
 		basic_machine=i386-sequent
 		;;
@@ -466,6 +921,13 @@
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparclite-wrs | simso-wrs)
+		basic_machine=sparclite-wrs
+		os=-vxworks
+		;;
 	sps7)
 		basic_machine=m68k-bull
 		os=-sysv2
@@ -473,6 +935,13 @@
 	spur)
 		basic_machine=spur-unknown
 		;;
+	st2000)
+		basic_machine=m68k-tandem
+		;;
+	stratus)
+		basic_machine=i860-stratus
+		os=-sysv4
+		;;
 	sun2)
 		basic_machine=m68000-sun
 		;;
@@ -513,13 +982,51 @@
 	sun386 | sun386i | roadrunner)
 		basic_machine=i386-sun
 		;;
+	sv1)
+		basic_machine=sv1-cray
+		os=-unicos
+		;;
 	symmetry)
 		basic_machine=i386-sequent
 		os=-dynix
 		;;
+	t3e)
+		basic_machine=alphaev5-cray
+		os=-unicos
+		;;
+	t90)
+		basic_machine=t90-cray
+		os=-unicos
+		;;
+	tic54x | c54x*)
+		basic_machine=tic54x-unknown
+		os=-coff
+		;;
+	tic55x | c55x*)
+		basic_machine=tic55x-unknown
+		os=-coff
+		;;
+	tic6x | c6x*)
+		basic_machine=tic6x-unknown
+		os=-coff
+		;;
+	tx39)
+		basic_machine=mipstx39-unknown
+		;;
+	tx39el)
+		basic_machine=mipstx39el-unknown
+		;;
+	toad1)
+		basic_machine=pdp10-xkl
+		os=-tops20
+		;;
 	tower | tower-32)
 		basic_machine=m68k-ncr
 		;;
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
+		;;
 	udi29k)
 		basic_machine=a29k-amd
 		os=-udi
@@ -528,6 +1035,10 @@
 		basic_machine=a29k-nyu
 		os=-sym1
 		;;
+	v810 | necv810)
+		basic_machine=v810-nec
+		os=-none
+		;;
 	vaxv)
 		basic_machine=vax-dec
 		os=-sysv
@@ -536,6 +1047,9 @@
 		basic_machine=vax-dec
 		os=-vms
 		;;
+	vpp*|vx|vx-*)
+		basic_machine=f301-fujitsu
+		;;
 	vxworks960)
 		basic_machine=i960-wrs
 		os=-vxworks
@@ -548,13 +1062,29 @@
 		basic_machine=a29k-wrs
 		os=-vxworks
 		;;
-	xmp)
-		basic_machine=xmp-cray
-		os=-unicos
+	w65*)
+		basic_machine=w65-wdc
+		os=-none
 		;;
-        xps | xps100)
+	w89k-*)
+		basic_machine=hppa1.1-winbond
+		os=-proelf
+		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
+	xps | xps100)
 		basic_machine=xps100-honeywell
 		;;
+	ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	z8k-*-coff)
+		basic_machine=z8k-unknown
+		os=-sim
+		;;
 	none)
 		basic_machine=none-none
 		os=-none
@@ -562,28 +1092,44 @@
 
 # Here we handle the default manufacturer of certain CPU types.  It is in
 # some cases the only manufacturer, in others, it is the most popular.
-	mips)
-		basic_machine=mips-mips
+	w89k)
+		basic_machine=hppa1.1-winbond
+		;;
+	op50n)
+		basic_machine=hppa1.1-oki
+		;;
+	op60c)
+		basic_machine=hppa1.1-oki
 		;;
 	romp)
 		basic_machine=romp-ibm
 		;;
+	mmix)
+		basic_machine=mmix-knuth
+		;;
 	rs6000)
 		basic_machine=rs6000-ibm
 		;;
 	vax)
 		basic_machine=vax-dec
 		;;
+	pdp10)
+		# there are many clones, so DEC is not a safe bet
+		basic_machine=pdp10-unknown
+		;;
 	pdp11)
 		basic_machine=pdp11-dec
 		;;
 	we32k)
 		basic_machine=we32k-att
 		;;
-	sparc)
+	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
+		basic_machine=sh-unknown
+		;;
+	sparc | sparcv8 | sparcv9 | sparcv9b)
 		basic_machine=sparc-sun
 		;;
-        cydra)
+	cydra)
 		basic_machine=cydra-cydrome
 		;;
 	orion)
@@ -592,6 +1138,15 @@
 	orion105)
 		basic_machine=clipper-highlevel
 		;;
+	mac | mpw | mac-mpw)
+		basic_machine=m68k-apple
+		;;
+	pmac | pmac-mpw)
+		basic_machine=powerpc-apple
+		;;
+	*-unknown)
+		# Make sure to match an already-canonicalized machine name.
+		;;
 	*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
@@ -615,6 +1170,8 @@
 if [ x"$os" != x"" ]
 then
 case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
 	# -solaris* is a basic system type, with this one exception.
 	-solaris1 | -solaris1.*)
 		os=`echo $os | sed -e 's|solaris1|sunos4|'`
@@ -622,34 +1179,87 @@
 	-solaris)
 		os=-solaris2
 		;;
-	-unixware* | svr4*)
+	-svr4*)
 		os=-sysv4
 		;;
+	-unixware*)
+		os=-sysv4.2uw
+		;;
 	-gnu/linux*)
-		os=`echo $os | sed -e 's|gnu/linux|linux|'`
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
 		;;
 	# First accept the basic system types.
 	# The portable systems comes first.
 	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[345]* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
-	      | -amigados* | -msdos* | -newsos* | -unicos* | -aos* \
-	      | -nindy* | -vxworks* | -ebmon* | -hms* | -mvs* | -clix* \
-	      | -riscos* | -linux* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -netbsd* | -freebsd* | -riscix* \
-	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
+	      | -openbsd* | -solidbsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
-	      | -udi* | -eabi* | -lites* )
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -chorusos* | -chorusrdb* \
+	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
+	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
+	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
+	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku* | -rdos*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
+	-qnx*)
+		case $basic_machine in
+		    x86-* | i*86-*)
+			;;
+		    *)
+			os=-nto$os
+			;;
+		esac
+		;;
+	-nto-qnx*)
+		;;
+	-nto*)
+		os=`echo $os | sed -e 's|nto|nto-qnx|'`
+		;;
+	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
+	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+		;;
+	-mac*)
+		os=`echo $os | sed -e 's|mac|macos|'`
+		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
 	-sunos5*)
 		os=`echo $os | sed -e 's|sunos5|solaris2|'`
 		;;
 	-sunos6*)
 		os=`echo $os | sed -e 's|sunos6|solaris3|'`
 		;;
+	-opened*)
+		os=-openedition
+		;;
+        -os400*)
+		os=-os400
+		;;
+	-wince*)
+		os=-wince
+		;;
 	-osfrose*)
 		os=-osfrose
 		;;
@@ -665,9 +1275,27 @@
 	-acis*)
 		os=-aos
 		;;
+	-atheos*)
+		os=-atheos
+		;;
+	-syllable*)
+		os=-syllable
+		;;
+	-386bsd)
+		os=-bsd
+		;;
 	-ctix* | -uts*)
 		os=-sysv
 		;;
+	-nova*)
+		os=-rtmk-nova
+		;;
+	-ns2 )
+		os=-nextstep2
+		;;
+	-nsk*)
+		os=-nsk
+		;;
 	# Preserve the version number of sinix5.
 	-sinix5.*)
 		os=`echo $os | sed -e 's|sinix|sysv|'`
@@ -675,6 +1303,9 @@
 	-sinix*)
 		os=-sysv4
 		;;
+        -tpf*)
+		os=-tpf
+		;;
 	-triton*)
 		os=-sysv3
 		;;
@@ -693,9 +1324,27 @@
 	# This must come after -sysvr4.
 	-sysv*)
 		;;
+	-ose*)
+		os=-ose
+		;;
+	-es1800*)
+		os=-ose
+		;;
 	-xenix)
 		os=-xenix
 		;;
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=-mint
+		;;
+	-aros*)
+		os=-aros
+		;;
+	-kaos*)
+		os=-kaos
+		;;
+	-zvmoe)
+		os=-zvmoe
+		;;
 	-none)
 		;;
 	*)
@@ -721,10 +1370,20 @@
 	*-acorn)
 		os=-riscix1.2
 		;;
+	arm*-rebel)
+		os=-linux
+		;;
 	arm*-semi)
 		os=-aout
 		;;
-        pdp11-*)
+    c4x-* | tic4x-*)
+        os=-coff
+        ;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=-tops20
+		;;
+	pdp11-*)
 		os=-none
 		;;
 	*-dec | vax-*)
@@ -742,15 +1401,45 @@
 		# default.
 		# os=-sunos4
 		;;
+	m68*-cisco)
+		os=-aout
+		;;
+	mips*-cisco)
+		os=-elf
+		;;
+	mips*-*)
+		os=-elf
+		;;
+	or32-*)
+		os=-coff
+		;;
 	*-tti)	# must be before sparc entry or we get the wrong os.
 		os=-sysv3
 		;;
 	sparc-* | *-sun)
 		os=-sunos4.1.1
 		;;
+	*-be)
+		os=-beos
+		;;
+	*-haiku)
+		os=-haiku
+		;;
 	*-ibm)
 		os=-aix
 		;;
+    	*-knuth)
+		os=-mmixware
+		;;
+	*-wec)
+		os=-proelf
+		;;
+	*-winbond)
+		os=-proelf
+		;;
+	*-oki)
+		os=-proelf
+		;;
 	*-hp)
 		os=-hpux
 		;;
@@ -761,7 +1450,7 @@
 		os=-sysv
 		;;
 	*-cbm)
-		os=-amigados
+		os=-amigaos
 		;;
 	*-dg)
 		os=-dgux
@@ -775,6 +1464,9 @@
 	m88k-omron*)
 		os=-luna
 		;;
+	*-next )
+		os=-nextstep
+		;;
 	*-sequent)
 		os=-ptx
 		;;
@@ -790,24 +1482,39 @@
 	*-next)
 		os=-nextstep3
 		;;
-        *-gould)
+	*-gould)
 		os=-sysv
 		;;
-        *-highlevel)
+	*-highlevel)
 		os=-bsd
 		;;
 	*-encore)
 		os=-bsd
 		;;
-        *-sgi)
+	*-sgi)
 		os=-irix
 		;;
-        *-siemens)
+	*-siemens)
 		os=-sysv4
 		;;
 	*-masscomp)
 		os=-rtu
 		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=-uxpv
+		;;
+	*-rom68k)
+		os=-coff
+		;;
+	*-*bug)
+		os=-coff
+		;;
+	*-apple)
+		os=-macos
+		;;
+	*-atari*)
+		os=-mint
+		;;
 	*)
 		os=-none
 		;;
@@ -826,15 +1533,18 @@
 			-sunos*)
 				vendor=sun
 				;;
-			-lynxos*)
-				vendor=lynx
-				;;
 			-aix*)
 				vendor=ibm
 				;;
+			-beos*)
+				vendor=be
+				;;
 			-hpux*)
 				vendor=hp
 				;;
+			-mpeix*)
+				vendor=hp
+				;;
 			-hiux*)
 				vendor=hitachi
 				;;
@@ -850,18 +1560,47 @@
 			-genix*)
 				vendor=ns
 				;;
-			-mvs*)
+			-mvs* | -opened*)
+				vendor=ibm
+				;;
+			-os400*)
 				vendor=ibm
 				;;
 			-ptx*)
 				vendor=sequent
 				;;
-			-vxworks*)
+			-tpf*)
+				vendor=ibm
+				;;
+			-vxsim* | -vxworks* | -windiss*)
 				vendor=wrs
 				;;
+			-aux*)
+				vendor=apple
+				;;
+			-hms*)
+				vendor=hitachi
+				;;
+			-mpw* | -macos*)
+				vendor=apple
+				;;
+			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+				vendor=atari
+				;;
+			-vos*)
+				vendor=stratus
+				;;
 		esac
 		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
 		;;
 esac
 
 echo $basic_machine$os
+exit
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff -Naur cdparanoia-III-alpha9.8.orig/header.c cdparanoia-III-alpha9.8/header.c
--- cdparanoia-III-alpha9.8.orig/header.c	1999-08-15 15:34:58.000000000 -0700
+++ cdparanoia-III-alpha9.8/header.c	2006-07-20 12:07:24.000000000 -0700
@@ -9,6 +9,7 @@
 
 #include <unistd.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 
 static void PutNum(long num,int f,int endianness,int bytes){
diff -Naur cdparanoia-III-alpha9.8.orig/interface/cdda_interface.h cdparanoia-III-alpha9.8/interface/cdda_interface.h
--- cdparanoia-III-alpha9.8.orig/interface/cdda_interface.h	2001-03-23 17:15:46.000000000 -0800
+++ cdparanoia-III-alpha9.8/interface/cdda_interface.h	2006-07-19 15:15:48.000000000 -0700
@@ -101,10 +101,46 @@
 
 } cdrom_drive;
 
+/* buffers for use with the scsi code.  d->sg_buffer is unused,
+   and d->sg points to this struct.  We can't really change struct
+   cdrom_drive without breaking binary compatibility, so we do this
+   instead. */
+struct sg_info {
+#ifdef SG_IO
+  struct sg_io_hdr *hdr;
+#else
+  struct sg_header *hdr;
+#endif
+
+  char *cmdp;
+  ssize_t cmd_len;
+  ssize_t cmdp_buffer_len;
+  
+  char *dxferp;
+  ssize_t dxferp_buffer_len;
+  ssize_t dxferp_max_buffer_len;
+
+  unsigned char bytefill;
+  int bytecheck;
+
+  int in_size;
+  int out_size;
+
+  int (*handle_scsi_cmd)(struct cdrom_drive *d);
+  void (*setup_scsi_cmd)(struct cdrom_drive *d,
+    char *cmdp, unsigned int cmd_len,
+    unsigned int in_size, unsigned int out_size);
+};
+
+
 #define IS_AUDIO(d,i) (!(d->disc_toc[i].bFlags & 0x04))
 
 /******** Identification/autosense functions */
 
+#ifdef SG_IO
+extern int check_fd_sgio(int fd);
+#endif
+
 extern cdrom_drive *cdda_find_a_cdrom(int messagedest, char **message);
 extern cdrom_drive *cdda_identify(const char *device, int messagedest,
 				  char **message);
diff -Naur cdparanoia-III-alpha9.8.orig/interface/common_interface.c cdparanoia-III-alpha9.8/interface/common_interface.c
--- cdparanoia-III-alpha9.8.orig/interface/common_interface.c	2000-04-19 15:41:04.000000000 -0700
+++ cdparanoia-III-alpha9.8/interface/common_interface.c	2006-07-19 15:05:43.000000000 -0700
@@ -223,7 +223,8 @@
       /* adjust end of last audio track to be in the first session */
       for (j = tracks-1; j >= 0; j--) {
 	if (j > 0 && !IS_AUDIO(d,j) && IS_AUDIO(d,j-1)) {
-	  if (d->disc_toc[j].dwStartSector > ms_str.addr.lba - 11400) 
+	  if ((d->disc_toc[j].dwStartSector > ms_str.addr.lba - 11400) &&
+            (ms_str.addr.lba - 11400 > d->disc_toc[j-1].dwStartSector))
 	    d->disc_toc[j].dwStartSector = ms_str.addr.lba - 11400;
 	  break;
 	}
diff -Naur cdparanoia-III-alpha9.8.orig/interface/interface.c cdparanoia-III-alpha9.8/interface/interface.c
--- cdparanoia-III-alpha9.8.orig/interface/interface.c	2000-04-19 15:41:04.000000000 -0700
+++ cdparanoia-III-alpha9.8/interface/interface.c	2006-07-19 15:15:48.000000000 -0700
@@ -30,7 +30,7 @@
 
     _clean_messages(d);
     if(d->cdda_device_name)free(d->cdda_device_name);
-    if(d->ioctl_device_name)free(d->ioctl_device_name);
+    if(d->ioctl_device_name && d->ioctl_device_name!=d->cdda_device_name)free(d->ioctl_device_name);
     if(d->drive_model)free(d->drive_model);
     if(d->cdda_fd!=-1)close(d->cdda_fd);
     if(d->ioctl_fd!=-1 && d->ioctl_fd!=d->cdda_fd)close(d->ioctl_fd);
diff -Naur cdparanoia-III-alpha9.8.orig/interface/Makefile.in cdparanoia-III-alpha9.8/interface/Makefile.in
--- cdparanoia-III-alpha9.8.orig/interface/Makefile.in	1999-12-13 20:27:59.000000000 -0800
+++ cdparanoia-III-alpha9.8/interface/Makefile.in	2006-07-19 15:22:27.000000000 -0700
@@ -10,6 +10,7 @@
 FLAGS=@SBPCD_H@ @UCDROM_H@ @TYPESIZES@ @CFLAGS@
 OPT=@OPT@ $(FLAGS)
 DEBUG=@DEBUG@ $(FLAGS) -DCDDA_TEST
+LIBFLAGS=-fPIC
 CC=@CC@
 LD=@CC@
 LDFLAGS=@LDFLAGS@ $(FLAGS)
@@ -18,7 +19,7 @@
 LIBS = -lm
 CPPFLAGS+=-D_REENTRANT
 
-OFILES = scan_devices.o	common_interface.o cooked_interface.o interface.o\
+OFILES = scan_devices.o	common_interface.o cooked_interface.o interface.o \
 	scsi_interface.o smallft.o toc.o test_interface.o
 
 export VERSION
@@ -33,7 +34,7 @@
 
 slib:	
 	$(MAKE) lessmessy
-	$(MAKE) libcdda_interface.so CFLAGS="$(OPT) -fpic" 
+	$(MAKE) libcdda_interface.so CFLAGS="$(OPT)" 
 	[ -e libcdda_interface.so.0 ] || ln -s libcdda_interface.so libcdda_interface.so.0
 
 test:	
@@ -46,12 +47,12 @@
 	$(RANLIB) libcdda_interface.a
 
 libcdda_interface.so: 	$(OFILES)	
-	$(CC) -fpic -shared -o libcdda_interface.so.0.$(VERSION) -Wl,-soname -Wl,libcdda_interface.so.0 $(OFILES)
+	$(CC) $(LDFLAGS) $(LIBFLAGS) -shared -o libcdda_interface.so.0.$(VERSION) -Wl,-soname -Wl,libcdda_interface.so.0 $(OFILES) -lm
 	[ -e libcdda_interface.so.0 ] || ln -s libcdda_interface.so.0.$(VERSION) libcdda_interface.so.0
 	[ -e libcdda_interface.so ] || ln -s libcdda_interface.so.0.$(VERSION) libcdda_interface.so
 
 .c.o:
-	$(CC) $(CFLAGS) -c $<
+	$(CC) $(CFLAGS) $(LIBFLAGS) -c $<
 
 lessmessy:
 	-rm  -f *.o core *~ *.out
diff -Naur cdparanoia-III-alpha9.8.orig/interface/scan_devices.c cdparanoia-III-alpha9.8/interface/scan_devices.c
--- cdparanoia-III-alpha9.8.orig/interface/scan_devices.c	2001-03-25 21:44:01.000000000 -0800
+++ cdparanoia-III-alpha9.8/interface/scan_devices.c	2006-07-19 15:16:28.000000000 -0700
@@ -10,12 +10,13 @@
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <errno.h>
 #include <ctype.h>
 #include <pwd.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include "cdda_interface.h"
 #include "low_interface.h"
+#include "cdda_interface.h"
 #include "common_interface.h"
 #include "utils.h"
 
@@ -50,6 +51,8 @@
   "/dev/gscd",
   "/dev/optcd",NULL};
 
+extern void sg2_init_sg_info(cdrom_drive *d);
+extern void sgio_init_sg_info(cdrom_drive *d);
 /* Functions here look for a cdrom drive; full init of a drive type
    happens in interface.c */
 
@@ -102,6 +105,7 @@
 cdrom_drive *cdda_identify(const char *device, int messagedest,char **messages){
   struct stat st;
   cdrom_drive *d=NULL;
+  char *transport = getenv("CDDA_TRANSPORT");
   idmessage(messagedest,messages,"Checking %s for cdrom...",device);
 
   if(stat(device,&st)){
@@ -117,8 +121,17 @@
   }
 #endif
 
-  d=cdda_identify_cooked(device,messagedest,messages);
-  if(!d)d=cdda_identify_scsi(device,NULL,messagedest,messages);
+#ifdef SG_IO
+  if (transport && !strcasecmp(transport, "cooked")) {
+#endif
+    d=cdda_identify_cooked(device,messagedest,messages);
+    if(!d)d=cdda_identify_scsi(device,NULL,messagedest,messages);
+#ifdef SG_IO
+  } else {
+    d=cdda_identify_scsi(device,NULL,messagedest,messages);
+    if(!d)d=cdda_identify_cooked(device,messagedest,messages);
+  }
+#endif
 
 #ifdef CDDA_TEST
   if(!d)d=cdda_identify_test(device,messagedest,messages);
@@ -148,7 +161,7 @@
 
   cdrom_drive *d=NULL;
   struct stat st;
-  int fd=-1;
+  int fd=-1, i;
   int type;
   char *description=NULL;
   char *device;
@@ -180,7 +193,12 @@
     /* Yay, ATAPI... */
     /* Ping for CDROM-ness */
     
-    fd=open(device,O_RDONLY|O_NONBLOCK);
+    fd=open(device,O_RDONLY|O_NONBLOCK|O_EXCL);
+    for (i = 0; i<10 && fd == -1 && errno == EBUSY; i++) {
+      fprintf(stderr, "Error trying to open %s exclusively (%s). retrying in 1 second.\n", device, strerror(errno));
+      usleep(1000000 + 100000.0 * rand()/(RAND_MAX+1.0));
+      fd = open(device,O_RDONLY|O_NONBLOCK|O_EXCL);
+    }
     if(fd==-1){
       idperror(messagedest,messages,"\t\tUnable to open %s",device);
       free(device);
@@ -250,14 +268,6 @@
     return(NULL);
   }
 
-  if(fd==-1)fd=open(device,O_RDONLY|O_NONBLOCK);
-  if(fd==-1){
-    idperror(messagedest,messages,"\t\tUnable to open %s",device);
-    free(device);
-    if(description)free(description);
-    return(NULL);
-  }
-  
   /* Minimum init */
   
   d=calloc(1,sizeof(cdrom_drive));
@@ -311,12 +321,19 @@
 			char *devfs_test,
 			char *devfs_other,
 			char *prompt,int messagedest,char **messages){
-  int dev=open(device,O_RDONLY|O_NONBLOCK);
+  int dev=-1;
   scsiid a,b;
 
   int i,j;
   char buffer[200];
 
+  dev=open(device,O_RDONLY|O_NONBLOCK|O_EXCL);
+  for (i = 0; i<10 && dev == -1 && errno == EBUSY; i++) {
+    fprintf(stderr, "Error trying to open %s exclusively (%s). retrying in 1 second.\n", device, strerror(errno));
+    usleep(1000000 + 100000.0 * rand()/(RAND_MAX+1.0));
+    dev = open(device,O_RDONLY|O_NONBLOCK|O_EXCL);
+  }
+
   /* if we're running under /devfs, build the device name from the
      device we already have */
   if(!strncmp(device,devfs_test,strlen(devfs_test))){
@@ -327,6 +344,11 @@
       int matchf;
       sprintf(pos,"/%s",devfs_other);
       matchf=open(buffer,O_RDONLY|O_NONBLOCK);
+      for (i = 0; (i<10) && (matchf==-1); i++) {
+        fprintf(stderr, "Error trying to open %s exclusively (%s). retrying in 1 seconds.\n", buffer, strerror(errno));
+        usleep(1000000 + 100000.0 * rand()/(RAND_MAX+1.0));
+        matchf = open(buffer,O_RDONLY|O_NONBLOCK);
+      }
       if(matchf!=-1){
 	close(matchf);
 	close(dev);
@@ -353,7 +375,7 @@
   for(i=0;i<25;i++){
     for(j=0;j<2;j++){
       int pattern=0;
-      int matchf;
+      int matchf, k;
       
       while(prefixes[pattern]!=NULL){
 	switch(j){
@@ -368,6 +390,12 @@
 	}
 	
 	matchf=open(buffer,O_RDONLY|O_NONBLOCK);
+	for (k = 0; (k<10) && (matchf==-1); k++) {
+	  fprintf(stderr, "Error trying to open %s exclusively (%s). retrying in 1 second.\n", buffer, strerror(errno));
+	  usleep(1000000 + 100000.0 * rand()/(RAND_MAX+1.0));
+	  matchf=open(buffer,O_RDONLY|O_NONBLOCK);
+	}
+
 	if(matchf!=-1){
 	  if(get_scsi_id(matchf,&b)==0){
 	    if(a.bus==b.bus && a.id==b.id && a.lun==b.lun){
@@ -412,17 +440,19 @@
 	    "\nFound an accessible SCSI CDROM drive."
 	    "\nLooking at revision of the SG interface in use...","");
 
-  if(ioctl(d->cdda_fd,SG_GET_VERSION_NUM,&version)){
+  if((version = ioctl(d->cdda_fd,SG_GET_VERSION_NUM,&major)) < 0){
     /* Up, guess not. */
     idmessage(messagedest,messages,
 	      "\tOOPS!  Old 2.0/early 2.1/early 2.2.x (non-ac patch) style "
 	      "SG.\n\tCdparanoia no longer supports the old interface.\n","");
     return(0);
   }
-  major=version/10000;
-  version-=major*10000;
-  minor=version/100;
-  version-=minor*100;
+  if (!version)
+    version = major;
+
+  major = (version >> 16) & 0xff;
+  minor = (version >> 8) & 0xff;
+  version &= 0xff;
   
   sprintf(buffer,"\tSG interface version %d.%d.%d; OK.",
 	  major,minor,version);
@@ -431,6 +461,139 @@
   return(major);
 }
 
+#ifdef SG_IO
+int get_sgio_fd(const char *device, int messagedest, char **messages) {
+	int fd;
+
+	if (!device)
+		return -errno;
+    	/* we don't really care what type of device it is -- if it can do
+	 * SG_IO, then we'll put it through the normal mmc/atapi/etc tests
+	 * later, but it's good enough for now. */
+	fd = open(device, O_RDWR|O_EXCL|O_NONBLOCK);
+ 	if (fd < 0)
+    		return -errno;
+	return check_fd_sgio(fd);
+}
+
+/* removing generic_device breaks ABI; instead, just test both devices */
+static cdrom_drive *sgio_cdda_identify_scsi(const char *generic_device, 
+				const char *ioctl_device, int messagedest,
+				char **messages){
+  cdrom_drive *d = NULL;
+  char *device = NULL;
+  int fd = -1, g_fd = -1;
+  char *p;
+
+  /* with SG_IO in 2.6, we much prefer /dev/hdc and /dev/scd0, so
+   * test ioctl_device before testing generic_device */
+
+  /* we need to resolve any symlinks for the lookup code to work */
+  if (ioctl_device)
+    device = test_resolve_symlink(ioctl_device, messagedest, messages);
+  /* test again, in case symlink resolution failed */
+  if (device) {
+    fd = get_sgio_fd(ioctl_device, messagedest, messages);
+    if (fd < 0) {
+      /* ioctl_device didn't work, so we don't need to keep the strdup of its
+       * real path around */
+      free(device);
+      device = NULL;
+    }
+  }
+  if (fd < 0) {
+    if (!generic_device)
+      goto cdda_identify_scsi_fail_free;
+    device = test_resolve_symlink(generic_device, messagedest, messages);
+    /* test again, in case symlink resolution failed */
+    if (!device)
+      goto cdda_identify_scsi_fail_return;
+    g_fd = get_sgio_fd(device, messagedest, messages);
+    if (g_fd < 0)
+      goto cdda_identify_scsi_fail_free;
+    fd = g_fd;
+  }
+
+  d=calloc(1,sizeof(cdrom_drive));
+
+  d->drive_type=SCSI_CDROM_MAJOR;
+  d->cdda_fd=fd;
+  d->ioctl_fd=fd;
+  d->bigendianp=-1; /* We don't know yet... */
+  d->nsectors=-1;
+  d->messagedest=messagedest;
+
+  d->interface=GENERIC_SCSI;
+
+  /* alloc our big buffer for scsi commands */
+  d->sg=calloc(1, sizeof (struct sg_info));
+  ((struct sg_info *)d->sg)->dxferp_max_buffer_len = CD_FRAMESIZE_RAW;
+  if (check_fd_sgio(d->cdda_fd)) 
+    sgio_init_sg_info(d);
+  else
+    sg2_init_sg_info(d);
+
+  /* get the lun -- this used to set 0 on failure, maybe still should */
+  d->lun = -1;
+
+  p = scsi_inquiry(d);
+  if (!p)
+    goto cdda_identify_scsi_fail_free_device;
+
+  /* It would seem some TOSHIBA CDROMs gets things wrong */
+ 
+  if (!strncmp (p + 8, "TOSHIBA", 7) &&
+      !strncmp (p + 16, "CD-ROM", 6) &&
+      p[0] == TYPE_DISK) {
+    p[0] = TYPE_ROM;
+    p[1] |= 0x80;     /* removable */
+  }
+
+  if (!p || (*p != TYPE_ROM && *p != TYPE_WORM)) {
+    idmessage(messagedest, messages,
+	      "\t\tDrive is neither a CDROM nor a WORM device\n", NULL);
+    goto cdda_identify_scsi_fail_free_device;
+  }
+
+  memcpy(d->inqbytes, p, 4);
+  d->cdda_device_name = device;
+  d->ioctl_device_name = device;
+
+  d->drive_model = calloc(1, 36);
+  strscat(d->drive_model, p+8, 8);
+  strscat(d->drive_model, p+16, 16);
+  strscat(d->drive_model, p+32, 4);
+
+  idmessage(messagedest, messages, "\nCDROM model sensed sensed: %s", d->drive_model);
+  
+  return d;
+  
+cdda_identify_scsi_fail_free_device:
+  if (d) {
+    if (d->drive_model)
+      free(d->drive_model);
+    if (d->sg) {
+      struct sg_info *sgi = (struct sg_info *)d->sg;
+      
+      if (sgi->cmdp_buffer_len)
+        free(sgi->cmdp);
+      if (sgi->dxferp_buffer_len)
+        free(sgi->dxferp);
+      if (sgi->hdr)
+        free(sgi->hdr);
+      free(d->sg);
+    }
+    free(d);
+  }
+  if (fd >= 0)
+    close(fd);
+cdda_identify_scsi_fail_free:
+  if (device)
+    free(device);
+cdda_identify_scsi_fail_return:
+  return NULL;
+}
+#endif
 cdrom_drive *cdda_identify_scsi(const char *generic_device, 
 				const char *ioctl_device, int messagedest,
 				char **messages){
@@ -438,12 +601,18 @@
   cdrom_drive *d=NULL;
   struct stat i_st;
   struct stat g_st;
-  int i_fd=-1;
+  int i_fd=-1, i;
   int g_fd=-1;
   int version;
   int type;
   char *p;
 
+#ifdef SG_IO
+  d = sgio_cdda_identify_scsi(generic_device, ioctl_device, messagedest, messages);
+  if (d)
+    return d;
+#endif
+
   if(generic_device)
     idmessage(messagedest,messages,"\tTesting %s for SCSI interface",
 	      generic_device);
@@ -534,8 +703,20 @@
     goto cdda_identify_scsi_fail;
   }
 
-  if(ioctl_device)i_fd=open(ioctl_device,O_RDONLY|O_NONBLOCK);
-  g_fd=open(generic_device,O_RDWR);
+  if(ioctl_device) {
+    i_fd=open(ioctl_device,O_RDONLY|O_NONBLOCK|O_EXCL);
+    for(i=0; i<10 && i_fd==-1 && errno == EBUSY; i++) {
+      fprintf(stderr, "Error trying to open %s exclusively (%s). retrying in 1 second.\n", ioctl_device, strerror(errno));
+      usleep(1000000 + 100000.0 * rand()/(RAND_MAX+1.0));
+      i_fd=open(ioctl_device,O_RDONLY|O_NONBLOCK|O_EXCL);
+    }
+  }
+  g_fd=open(generic_device,O_RDWR|O_EXCL);
+  for(i=0; i<10 && g_fd==-1 && errno == EBUSY; i++) {
+    fprintf(stderr, "Error trying to open %s exclusively (%s). retrying in 1 second.\n", generic_device, strerror(errno));
+    usleep(1000000 + 100000.0 * rand()/(RAND_MAX+1.0));
+    g_fd=open(generic_device,O_RDWR|O_EXCL);
+  }
   
   if(ioctl_device && i_fd==-1)
     idperror(messagedest,messages,"\t\tCould not open SCSI cdrom device "
@@ -580,7 +761,6 @@
 	      "major number",generic_device);
     goto cdda_identify_scsi_fail;
   }
-  
 
   d=calloc(1,sizeof(cdrom_drive));
 
@@ -601,8 +781,9 @@
   }
 
   /* malloc our big buffer for scsi commands */
-  d->sg=malloc(MAX_BIG_BUFF_SIZE);
-  d->sg_buffer=d->sg+SG_OFF;
+  d->sg=calloc(1, sizeof (struct sg_info));
+  ((struct sg_info *)d->sg)->dxferp_max_buffer_len = CD_FRAMESIZE_RAW;
+  sg2_init_sg_info(d);
 
   {
     /* get the lun */
@@ -614,10 +795,12 @@
   }
 
   p = scsi_inquiry(d);
+  if (!p)
+    goto cdda_identify_scsi_fail;
 
   /* It would seem some TOSHIBA CDROMs gets things wrong */
  
-  if (!strncmp (p + 8, "TOSHIBA", 7) &&
+  if (p && !strncmp (p + 8, "TOSHIBA", 7) &&
       !strncmp (p + 16, "CD-ROM", 6) &&
       p[0] == TYPE_DISK) {
     p[0] = TYPE_ROM;
@@ -632,12 +815,11 @@
     goto cdda_identify_scsi_fail;
   }
 
-  d->drive_model=calloc(36,1);
   memcpy(d->inqbytes,p,4);
   d->cdda_device_name=copystring(generic_device);
   d->ioctl_device_name=copystring(ioctl_device);
 
-  d->drive_model=calloc(36,1);
+  d->drive_model=calloc(1, 36);
   strscat(d->drive_model,p+8,8);
   strscat(d->drive_model,p+16,16);
   strscat(d->drive_model,p+32,4);
@@ -647,6 +829,22 @@
   return(d);
   
 cdda_identify_scsi_fail:
+  if (d) {
+    if (d->drive_model)
+      free(d->drive_model);
+    if (d->sg) {
+      struct sg_info *sgi = (struct sg_info *)d->sg;
+      
+      if (sgi->cmdp_buffer_len)
+        free(sgi->cmdp);
+      if (sgi->dxferp_buffer_len)
+        free(sgi->dxferp);
+      if (sgi->hdr)
+        free(sgi->hdr);
+      free(d->sg);
+    }
+    free(d);
+  }
   if(generic_device)free((char *)generic_device);
   if(ioctl_device)free((char *)ioctl_device);
   if(i_fd!=-1)close(i_fd);
@@ -661,7 +859,7 @@
   
   cdrom_drive *d=NULL;
   struct stat st;
-  int fd=-1;
+  int fd=-1,i;
 
   idmessage(messagedest,messages,"\tTesting %s for file/test interface",
 	    filename);
@@ -678,7 +876,17 @@
     return(NULL);
   }
 
-  fd=open(filename,O_RDONLY);
+  /* I'm not certain this one nees O_EXCL, but it can't hurt */
+  fd=open(filename,O_RDONLY|O_EXCL);
+  for(i=0; i<10 && fd==-1 && errno == EBUSY; i++) {
+    fprintf(stderr, "Error trying to open %s exclusively (%s). retrying in 1 second.\n", filename, strerror(errno));
+    usleep(1000000 + 100000.0 * rand()/(RAND_MAX+1.0));
+    fd=open(filename,O_RDONLY|O_EXCL);
+  }
+  
+  if(ioctl_device && i_fd==-1)
+    idperror(messagedest,messages,"\t\tCould not open SCSI cdrom device "
+	     "%s (continuing)",ioctl_device);
   
   if(fd==-1){
     idperror(messagedest,messages,"\t\tCould not open file %s",filename);
diff -Naur cdparanoia-III-alpha9.8.orig/interface/scsi_cmds.h cdparanoia-III-alpha9.8/interface/scsi_cmds.h
--- cdparanoia-III-alpha9.8.orig/interface/scsi_cmds.h	1969-12-31 16:00:00.000000000 -0800
+++ cdparanoia-III-alpha9.8/interface/scsi_cmds.h	2006-07-19 15:15:48.000000000 -0700
@@ -0,0 +1,197 @@
+/******************************************************************
+ * CopyPolicy: GNU General Public License version 2
+ * Copyright 2004 Peter Jones <pjones@redhat.com>
+ * 
+ * macros to generate scsi commands.
+ *
+ ******************************************************************/
+
+#ifndef _SCSI_CMDS_H
+#define _SCSI_CMDS_H 1
+#include <scsi/scsi.h>
+
+/* from the MMC3 spec, rewritten as seperate macros */
+#define LBA_to_M(lba) (lba>=-150?((lba+150)/(60*75)):((lba+450150)/(60*75)))
+#define LBA_to_S(lba) (lba>=-150?((lba+150)/75):((lba+450150)/75))
+#define LBA_to_F(lba) (lba>=-150?(lba+150):(lba+450150))
+
+/* Group 1 (10b) command */
+#define SCSI_TWELVE_BYTE(a,b,c,d,e,f,g,h,i,j,k,l) ((char []) {a,b,c,d,e,f,g,h,i,j,k,l})
+#define SCSI_READ_12(fua, a, l) SCSI_TWELVE_BYTE( \
+	READ_12,		/* READ_10 */ \
+	(fua & 1) << 3,		/* force unit access */ \
+	(a >> 24) & 0xff,	/* lba byte 3 */ \
+	(a >> 16) & 0xff,	/* lba byte 2 */ \
+	(a >> 8) & 0xff,	/* lba byte 1 */ \
+	a & 0xff,		/* lba byte 0 */ \
+	0,			/* reserved */ \
+	(l >> 24) & 0xff,	/* len byte 3 */ \
+	(l >> 16) & 0xff,	/* len byte 2 */ \
+	(l >> 8) & 0xff,	/* len byte 1 */ \
+	l & 0xff,		/* len byte 0 */ \
+	0			/* control */ \
+)
+#define D4_READ_12(a, l) SCSI_TWELVE_BYTE( \
+	0xD4,			/* 0xD4 */ \
+	0,			/* lun */ \
+	0,			/* ? */ \
+	(a >> 16) & 0xff,	/* lba byte 2 */ \
+	(a >> 8) & 0xff,	/* lba byte 1 */ \
+	a & 0xff,		/* lba byte 0 */ \
+	0,			/* reserved */ \
+	0,			/* ? */ \
+	0,			/* ? */ \
+	l & 0xff,		/* len byte 0 */ \
+	0, 0			/* ? */ \
+)
+#define D8_READ_12(a, l) SCSI_TWELVE_BYTE( \
+	0xD8,			/* 0xD4 */ \
+	0,			/* lun */ \
+	0,			/* ? */ \
+	(a >> 16) & 0xff,	/* lba byte 2 */ \
+	(a >> 8) & 0xff,	/* lba byte 1 */ \
+	a & 0xff,		/* lba byte 0 */ \
+	0,			/* reserved */ \
+	0,			/* ? */ \
+	0,			/* ? */ \
+	l & 0xff,		/* len byte 0 */ \
+	0, 0			/* ? */ \
+)
+#define READ_CD_12(a, l) SCSI_TWELVE_BYTE( \
+	0xBE,			/* 0xD4 */ \
+	0,			/* ? */ \
+	(a >> 24) & 0xff,	/* lba byte 3 */ \
+	(a >> 16) & 0xff,	/* lba byte 2 */ \
+	(a >> 8) & 0xff,	/* lba byte 1 */ \
+	a & 0xff,		/* lba byte 0 */ \
+	(l >> 16) & 0xff,	/* len byte 2 */ \
+	(l >> 8) & 0xff,	/* len byte 1 */ \
+	l & 0xff,		/* len byte 0 */ \
+	10,			/* ecc */ \
+	0, 0			/* ? */ \
+)
+#define READ_CD_MSF_12(a, l) SCSI_TWELVE_BYTE( \
+	0xB9,			/* 0xD4 */ \
+	0,			/* ? */ \
+	0,			/* ? */ \
+	LBA_to_M((a)),		/* start M */ \
+	LBA_to_S((a)),		/* start S */ \
+	LBA_to_F((a)),		/* start F */ \
+	LBA_to_M((a)+(l)),	/* start M */ \
+	LBA_to_S((a)+(l)),	/* start S */ \
+	LBA_to_F((a)+(l)),	/* start F */ \
+	10,			/* ecc */ \
+	0, 0			/* ? */ \
+)
+
+#define SCSI_TEN_BYTE(a,b,c,d,e,f,g,h,i,j) ((char []) {a,b,c,d,e,f,g,h,i,j})
+#define SCSI_MODE_SENSE_10(page, size) SCSI_TEN_BYTE( \
+	MODE_SENSE_10,	/* MODE_SENSE */ \
+	0x00,		/* reserved */ \
+	page & 0x3F,		/* page */ \
+	0,		/* reserved */ \
+	0,		/* reserved */ \
+	0,		/* reserved */ \
+	0,		/* reserved */ \
+	0,		/* MSB (0) */ \
+	size,		/* sizeof(modesense - SG_OFF) */ \
+	0		/* reserved */ \
+)
+#define SCSI_MODE_SELECT_10 SCSI_TEN_BYTE( \
+	MODE_SELECT_10,	/* MODE_SELECT */ \
+	0x10,		/* no save page */ \
+	0,		/* reserved */ \
+	0,		/* reserved */ \
+	0,		/* reserved */ \
+	0,		/* reserved */ \
+	0,		/* reserved */ \
+	0,		/* reserved */ \
+	12,		/* sizeof(mode) */ \
+	0		/* reserved */ \
+)
+#define SCSI_READ_TOC(track_number) SCSI_TEN_BYTE( \
+	READ_TOC,	/* READ_TOC */ \
+	0,		/* MSF format */ \
+	0,		\
+	0,		\
+	0,		\
+	0,		\
+	track_number,	/* start track */ \
+	0,		/* len msb */ \
+	12,		/* len lsb */ \
+	0		/* flags */ \
+)
+/* a contribution from Boris for IMS cdd 522 */
+/* check this for ACER/Creative/Foo 525,620E,622E, etc? */
+#define CDD522_READ_TOC(track_number) SCSI_TEN_BYTE( \
+	0xE5,		/* CDD522_READ_TOC */ \
+	0, 0, 0, 0,	/* res */ \
+	track_number,	/* start track */ \
+	0, 0, 0, 0	/* ? */ \
+)
+#define SCSI_READ_10(fua, a, l) SCSI_TEN_BYTE( \
+	READ_10,		/* READ_10 */ \
+	(fua?8:0),		/* force unit access */ \
+	(a >> 24) & 0xff,	/* lba byte 3 */ \
+	(a >> 16) & 0xff,	/* lba byte 2 */ \
+	(a >> 8) & 0xff,	/* lba byte 1 */ \
+	a & 0xff,		/* lba byte 0 */ \
+	0,			/* reserved */ \
+	(l >> 8) & 0xff,	/* len byte 1 */ \
+	l & 0xff,		/* len byte 0 */ \
+	0			/* control */ \
+)
+#define D4_READ_10(a, l) SCSI_TEN_BYTE( \
+	0xD4,			/* 0xD4 */ \
+	0,			/* ? */ \
+	0,			/* ? */ \
+	(a >> 16) & 0xff,	/* lba byte 2 */ \
+	(a >> 8) & 0xff,	/* lba byte 1 */ \
+	a & 0xff,		/* lba byte 0 */ \
+	0,			/* reserved */ \
+	0,			/* ? */ \
+	l & 0xff,		/* len byte 0 */ \
+	0			/* control */ \
+)
+#define D5_READ_10(a, l) SCSI_TEN_BYTE( \
+	0xD5,			/* 0xD5 */ \
+	0,			/* lun */ \
+	0,			/* ? */ \
+	(a >> 16) & 0xff,	/* lba byte 2 */ \
+	(a >> 8) & 0xff,	/* lba byte 1 */ \
+	a & 0xff,		/* lba byte 0 */ \
+	0,			/* reserved */ \
+	0,			/* ? */ \
+	l & 0xff,		/* len byte 0 */ \
+	0			/* control */ \
+)
+
+
+#define SCSI_SIX_BYTE(a,b,c,d,e,f) ((char []) {a,b,c,d,e,f})
+#define SCSI_MODE_SENSE_6(page, size) SCSI_SIX_BYTE( \
+	MODE_SENSE,	/* MODE_SENSE */ \
+	0x00,		/* return block descriptor/lun */ \
+	page & 0x3F,		/* page */ \
+	0,		/* reserved */ \
+	size,		/* sizeof(modesense - SG_OFF) */ \
+	0		/* control */  \
+)
+#define SCSI_MODE_SELECT_6 SCSI_SIX_BYTE( \
+	MODE_SELECT,	/* MODE_SELECT */ \
+	0x10,		/* no save page */ \
+	0,		/* reserved */ \
+	0,		/* reserved */ \
+	12,		/* sizeof(mode) */ \
+	0		/* reserved */ \
+)
+#define SCSI_INQUIRY_6(len) SCSI_SIX_BYTE( \
+	INQUIRY,	/* INQUIRY */ \
+	0, 0, 0,	/* ? */ \
+	len, 0		/* len, ? */ \
+)
+#define SCSI_TEST_UNIT_READY_6 SCSI_SIX_BYTE( \
+	TEST_UNIT_READY,/* TEST_UNIT_READY */ \
+	0, 0, 0, 0,	/* reserved */ \
+	0		/* control */ \
+)
+#endif
diff -Naur cdparanoia-III-alpha9.8.orig/interface/scsi_interface.c cdparanoia-III-alpha9.8/interface/scsi_interface.c
--- cdparanoia-III-alpha9.8.orig/interface/scsi_interface.c	2001-03-23 17:15:46.000000000 -0800
+++ cdparanoia-III-alpha9.8/interface/scsi_interface.c	2006-07-19 15:16:14.000000000 -0700
@@ -3,6 +3,7 @@
  * Original interface.c Copyright (C) 1994-1997 
  *            Eissfeldt heiko@colossus.escape.de
  * Current blenderization Copyright (C) 1998-1999 Monty xiphmont@mit.edu
+ *                        Copyright 2004 Peter Jones <pjones@redhat.com>
  * 
  * Generic SCSI interface specific code.
  *
@@ -11,6 +12,7 @@
 #include "low_interface.h"
 #include "common_interface.h"
 #include "utils.h"
+#include "scsi_cmds.h"
 
 /* hook */
 static int Dummy (cdrom_drive *d,int s){
@@ -19,66 +21,299 @@
 
 #include "drive_exceptions.h"
 
-static void tweak_SG_buffer(cdrom_drive *d){
-  int table,reserved;
-  char buffer[256];
+static void reset_scsi(cdrom_drive *d){
+  struct sg_info *sgi = (struct sg_info *)d->sg;
+  struct sg_io_hdr *hdr = sgi->hdr;
+  unsigned char key, ASC, ASCQ;
+  int arg, ret, tries;
+  char cmd[6];
 
-  /* maximum transfer size? */
-  if(ioctl(d->cdda_fd,SG_GET_RESERVED_SIZE,&reserved)){
-    /* Up, guess not. */
-    cdmessage(d,"\tCould not get scatter/gather buffer size.\n");
-    return;
+  d->enable_cdda(d,0);
+
+  cdmessage(d,"sending SG SCSI reset... ");
+  if(ioctl(d->cdda_fd,SG_SCSI_RESET,&arg))
+    cdmessage(d,"FAILED: EBUSY\n");
+  else
+    cdmessage(d,"OK\n");
+
+  tries = 0;
+  while(1) {
+    memcpy(cmd, SCSI_TEST_UNIT_READY_6, 6);
+    sgi->setup_scsi_cmd(d, cmd, 6, 0, 56);
+    ret = sgi->handle_scsi_cmd(d);
+
+    key = hdr->sbp[2] & 0xf;
+    ASC = hdr->sbp[12];
+    ASCQ = hdr->sbp[13];
+
+    if(key == 2 & ASC == 4 & ASCQ == 1 & tries < 10) {
+      tries++;
+      usleep(10);
+      continue;
+    }
+    break;
   }
 
-  if(ioctl(d->cdda_fd,SG_GET_SG_TABLESIZE,&table))table=1;
-  {
-    int cur;
+  d->enable_cdda(d,1);
+}
 
-    sprintf(buffer,"\tDMA scatter/gather table entries: %d\n\t"
-	    "table entry size: %d bytes\n\t"
-	    "maximum theoretical transfer: %d sectors\n",
-	    table,reserved,table*reserved/CD_FRAMESIZE_RAW);
-    cdmessage(d,buffer);
+static int check_sbp_error(const char *sbp) {
+  char key = sbp[2] & 0xf;
+  char ASC = sbp[12];
+  char ASCQ = sbp[13];
 
-    cur=table*reserved;
+  if (sbp[0]) {
+    switch (key){
+      case 0:
+        if (errno==0)
+	  errno = EIO;
+        return(TR_UNKNOWN);
+      case 1:
+        break;
+      case 2:
+        if (errno==0)
+	  errno = EBUSY;
+        return(TR_BUSY);
+      case 3: 
+        if ((ASC==0x0C) & (ASCQ==0x09)) {
+	  /* loss of streaming */
+	  if (errno==0)
+	    errno = EIO;
+          return(TR_STREAMING);
+	} else {
+	  if (errno==0)
+	    errno = EIO;
+	  return(TR_MEDIUM);
+        }
+      case 4:
+        if (errno==0)
+	  errno = EIO;
+        return(TR_FAULT);
+      case 5:
+        if (errno==0)
+	  errno = EINVAL;
+        return(TR_ILLEGAL);
+      default:
+        if (errno==0)
+	  errno = EIO;
+        return(TR_UNKNOWN);
+    }
+  }
+  return 0;
+}
 
-    /* not too much; new kernels have trouble with DMA allocation, so
-       be more conservative: 32kB max until I test more thoroughly */
-    cur=(cur>1024*32?1024*32:cur);
-    d->nsectors=cur/CD_FRAMESIZE_RAW;
-    d->bigbuff=cur;
+#ifdef SG_IO
+int check_fd_sgio(int fd) {
+  struct sg_io_hdr hdr;
+
+  if (fd < 0)
+    return fd;
+
+  memset(&hdr, 0, sizeof (struct sg_io_hdr));
+  /* First try with interface_id = 'A'; for all but the sg case,
+   * that'll get us a -EINVAL if it supports SG_IO, and some other
+   * error for all other cases. */
+  hdr.interface_id = 'A';
+  if (ioctl(fd, SG_IO, &hdr)) {
+    switch (errno) {
+      /* sr and ata give us EINVAL when SG_IO is supported
+       * but interface_id is bad. */
+      case EINVAL:
+      /* sg gives us ENOSYS when SG_IO is supported but
+       * interface_id is bad.  IMHO, this is wrong and 
+       * needs fixing in the kernel. */
+      case ENOSYS:
+        return fd;
+      /* everything else gives ENOTTY, I think.  I'm just
+       * going to be paranoid and reject everything else. */
+      default:
+        return -errno;
+    }
+  }
+  /* if we get here, something is dreadfuly wrong. ioctl(fd,SG_IO,&hdr)
+   * handled SG_IO, but took hdr.interface_id = 'A' as valid, and an empty
+   * command as good.  Don't trust it. */
+  return -1;
+}
 
-    sprintf(buffer,"\tSetting default read size to %d sectors (%d bytes).\n\n",
-	    d->nsectors,d->nsectors*CD_FRAMESIZE_RAW);
-    cdmessage(d,buffer);
-  } 
+static void sgio_tweak_SG_buffer(cdrom_drive *d) {
+  int table, reserved, cur, err;
+  char buffer[256];
 
-  /* Disable command queue; we don't need it, no reason to have it on */
-  reserved=0;
-  if(ioctl(d->cdda_fd,SG_SET_COMMAND_Q,&reserved)){
-    cdmessage(d,"\tCouldn't disable command queue!  Continuing anyway...\n");
+  /* SG_SET_RESERVED_SIZE doesn't actually allocate or reserve anything.
+   * what it _does_ do is give you an error if you ask for a value
+   * larger than q->max_sectors (the length of the device's bio request
+   * queue).  So we walk it up from 1 sector until it fails, then get
+   * the value we set it to last.
+   */
+  /* start with 2 frames, round down to our queue's sector size */
+  cur = 1;
+  do {
+    cur <<= 1; reserved = cur * (1<<9);
+    err = ioctl(d->cdda_fd, SG_SET_RESERVED_SIZE, &reserved);
+  } while(err >= 0);
+  ioctl(d->cdda_fd, SG_GET_RESERVED_SIZE, &reserved);
+
+  cur = 0;
+  /* this doesn't currently ever work, but someday somebody might
+     implement working sg lists with SG_IO devices, so who knows... */
+  table=1;
+  if (ioctl(d->cdda_fd, SG_GET_SG_TABLESIZE, &table) < 0)
+    table=1;
+
+  sprintf(buffer,"\tDMA scatter/gather table entries: %d\n\t"
+      "table entry size: %d bytes\n\t"
+      "maximum theoretical transfer: %d sectors\n",
+      table, reserved, table*reserved/CD_FRAMESIZE_RAW);
+  cdmessage(d,buffer);
+
+  cur=table*reserved;
+
+  /* so since we never go above q->max_sectors, we should never get -EIO.
+   * we might still get -ENOMEM, but we back off for that later.  Monty
+   * had an old comment: "not too much; new kernels have trouble with DMA
+   * "allocation, so be more conservative: 32kB max until I test more 
+   * thoroughly".  We're not currently honoring that, because we should
+   * always get -ENOMEM.
+   *
+   * Updated: but we don't always get -ENOMEM.  Sometimes USB drives 
+   * still fail the wrong way.  This needs some kernel-land investigation.
+   */
+#if 1
+  if (!getenv("CDDA_IGNORE_BUFSIZE_LIMIT")) {
+    cur=(cur>2352*24?2352*24:cur);
+  }
+#endif
+  ((struct sg_info *)d->sg)->dxferp_max_buffer_len = cur;
+
+  d->nsectors=cur/CD_FRAMESIZE_RAW;
+  d->bigbuff=cur;
+
+  sprintf(buffer,"\tSetting default read size to %d sectors (%d bytes).\n\n",
+      d->nsectors,d->nsectors*CD_FRAMESIZE_RAW);
+  cdmessage(d,buffer);
+}
+
+static void sgio_setup_scsi_cmd(cdrom_drive *d,
+				char *cmdp,
+				unsigned int cmd_len,
+				unsigned int in_size,
+				unsigned int out_size) {
+  struct sg_info *sgi = (struct sg_info *)d->sg;
+  struct sg_io_hdr *hdr = sgi->hdr;
+
+  memset(hdr->cmdp, 0, sgi->cmdp_buffer_len);
+  memset(hdr->dxferp, sgi->bytefill, sgi->dxferp_buffer_len);
+  memcpy(hdr->cmdp, cmdp, cmd_len);
+
+  sgi->cmd_len = hdr->cmd_len = cmd_len;
+
+  sgi->in_size = in_size;
+  sgi->out_size = out_size;
+}
+
+void print_cmd_error(cdrom_drive *d, char *direction, char *cmdp, int cmdlen) {
+  unsigned char ebuf[1024], tmp[2];
+  int x=0;
+
+  sprintf(ebuf, "\nError %s command: ", direction);
+  cdmessage(d, ebuf);
+  tmp[1] = 0;
+  while (x < cmdlen) {
+    if (x % 8 == 0)
+      cdmessage(d, " ");
+    if (x % 16 == 0) {
+      cdmessage(d, "\n");
+      if (x+1 < cmdlen)
+        cdmessage(d, "\t");
+    }	
+    tmp[0] = cmdp[x];
+    sprintf(ebuf, "%02x ", tmp[0]);
+    cdmessage(d, ebuf);
+    x++;
+  }
+  if (!(x % 16 == 0))
+    cdmessage(d, "\n");
+}
+
+static int sgio_handle_scsi_cmd(cdrom_drive *d) {
+  int status = 0;
+  struct sg_info *sgi = (struct sg_info *)d->sg;
+  struct sg_io_hdr *hdr = sgi->hdr;
+  char ebuf[256];
+
+  if (sgi->in_size) {
+    hdr->dxfer_len = sgi->in_size;
+    hdr->dxfer_direction = SG_DXFER_TO_DEV;
+
+    errno = 0;
+    status = ioctl(d->cdda_fd, SG_IO, hdr);
+    if (status >= 0)
+      if (hdr->status)
+        status = check_sbp_error(hdr->sbp);
+    if (status < 0) {
+      print_cmd_error(d, "writing", sgi->cmdp, sgi->cmd_len);
+      return TR_EWRITE;
+    }
+  }
+  if (!sgi->in_size | sgi->out_size) {
+    hdr->dxfer_len = sgi->out_size;
+    hdr->dxfer_direction = sgi->out_size ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
+
+    errno = 0;
+    status = ioctl(d->cdda_fd, SG_IO, hdr);
+    if (status < 0) {
+      print_cmd_error(d, "reading", hdr->cmdp, hdr->cmd_len);
+      return TR_EREAD;
+    }
+    if (status >= 0)
+      if (hdr->status)
+        status = check_sbp_error(hdr->sbp);
+  }
+  if (status) {
+    print_cmd_error(d, "reading", hdr->cmdp, hdr->cmd_len);
+    return status;
   }
 
+  errno = 0;
+  return 0;
 }
 
-static void reset_scsi(cdrom_drive *d){
-  int arg;
-  d->enable_cdda(d,0);
+void sgio_init_sg_info(cdrom_drive *d) {
+  struct sg_info *sgi = (struct sg_info *)d->sg;
+  struct sg_io_hdr *hdr;
 
-  cdmessage(d,"sending SG SCSI reset... ");
-  if(ioctl(d->cdda_fd,SG_SCSI_RESET,&arg))
-    cdmessage(d,"FAILED: EBUSY\n");
-  else
-    cdmessage(d,"OK\n");
-  
-  d->enable_cdda(d,1);
+  hdr = calloc(sizeof (struct sg_io_hdr), 1);
+
+  sgi->cmdp = hdr->cmdp = calloc(128, 1);
+  sgi->cmdp_buffer_len = 128;
+
+  hdr->sbp = calloc(SG_MAX_SENSE,1);
+  hdr->mx_sb_len = SG_MAX_SENSE;
+
+  sgi->bytefill = '\xff';
+  sgi->bytecheck = 0;
+
+  hdr->timeout = 5000;
+  hdr->interface_id = 'S';
+
+  sgi->hdr = hdr;
+
+  sgi->setup_scsi_cmd = sgio_setup_scsi_cmd;
+  sgi->handle_scsi_cmd = sgio_handle_scsi_cmd;
+
+  sgio_tweak_SG_buffer(d);
+
+  sgi->dxferp = hdr->dxferp = calloc(sgi->dxferp_max_buffer_len, 1);
+  sgi->dxferp_buffer_len = sgi->dxferp_max_buffer_len;
 }
+#endif
 
-static void clear_garbage(cdrom_drive *d){
+static void sg2_clear_garbage(cdrom_drive *d){
   fd_set fdset;
   struct timeval tv;
-  struct sg_header *sg_hd=(struct sg_header *)d->sg;
-  int flag=0;
+  struct sg_header *sg_hd = (struct sg_header *)((struct sg_info *)d->sg)->hdr;
+  int flag = 0;
 
   /* clear out any possibly preexisting garbage */
   FD_ZERO(&fdset);
@@ -105,27 +340,87 @@
   }
 }
 
+static void sg2_tweak_SG_buffer(cdrom_drive *d){
+  int table,reserved;
+  char buffer[256];
+
+  /* maximum transfer size? */
+  if(ioctl(d->cdda_fd,SG_GET_RESERVED_SIZE,&reserved)){
+    /* Up, guess not. */
+    cdmessage(d,"\tCould not get scatter/gather buffer size.\n");
+    return;
+  }
+
+  if(ioctl(d->cdda_fd,SG_GET_SG_TABLESIZE,&table))table=1;
+  {
+    int cur;
+
+    sprintf(buffer,"\tDMA scatter/gather table entries: %d\n\t"
+	    "table entry size: %d bytes\n\t"
+	    "maximum theoretical transfer: %d sectors\n",
+	    table,reserved,table*reserved/CD_FRAMESIZE_RAW);
+    cdmessage(d,buffer);
+
+    cur=table*reserved;
+
+    /* not too much; new kernels have trouble with DMA allocation, so
+       be more conservative: 32kB max until I test more thoroughly */
+    cur=(cur>1024*32?1024*32:cur);
+    d->nsectors=cur/CD_FRAMESIZE_RAW;
+    d->bigbuff=cur;
+
+    sprintf(buffer,"\tSetting default read size to %d sectors (%d bytes).\n\n",
+	    d->nsectors,d->nsectors*CD_FRAMESIZE_RAW);
+    cdmessage(d,buffer);
+  } 
+
+  /* Disable command queue; we don't need it, no reason to have it on */
+  reserved=0;
+  if(ioctl(d->cdda_fd,SG_SET_COMMAND_Q,&reserved)){
+    cdmessage(d,"\tCouldn't disable command queue!  Continuing anyway...\n");
+  }
+}
+
 /* process a complete scsi command. */
-static int handle_scsi_cmd(cdrom_drive *d,
-			   unsigned int cmd_len, 
-			   unsigned int in_size, 
-			   unsigned int out_size,
 
-			   unsigned char bytefill,
-			   int bytecheck){
+static void sg2_setup_scsi_cmd(cdrom_drive *d,
+				char *cmdp,
+				unsigned int cmd_len,
+				unsigned int in_size,
+				unsigned int out_size) {
+  struct sg_info *sgi = (struct sg_info *)d->sg;
+  struct sg_header *hdr = (struct sg_header *)sgi->hdr;
+
+  sgi->cmdp = (char *)hdr + sizeof (struct sg_header);
+  sgi->cmd_len = cmd_len;
+  memcpy(sgi->cmdp, cmdp, cmd_len);
+
+  sgi->dxferp = sgi->cmdp + cmd_len;
+  memset(sgi->dxferp, sgi->bytefill, sgi->dxferp_max_buffer_len - cmd_len);
+
+  sgi->in_size = in_size;
+  sgi->out_size = out_size;
+}
+
+static int sg2_handle_scsi_cmd(cdrom_drive *d) {
   int status = 0;
-  struct sg_header *sg_hd=(struct sg_header *)d->sg;
-  long writebytes=SG_OFF+cmd_len+in_size;
+  struct sg_info *sgi = (struct sg_info *)d->sg;
+  struct sg_header *sg_hd = (struct sg_header *)sgi->hdr;
+
+  int out_size = sgi->out_size;
+  int in_size = sgi->in_size;
+
+  long writebytes = (int)(sg_hd) + SG_OFF + sgi->cmd_len + sgi->in_size;
 
   /* generic scsi device services */
 
   /* clear out any possibly preexisting garbage */
-  clear_garbage(d);
+  sg2_clear_garbage(d);
 
-  memset(sg_hd,0,sizeof(sg_hd)); 
-  sg_hd->twelve_byte = cmd_len == 12;
+  memset(sg_hd,0, SG_OFF); 
+  sg_hd->twelve_byte = sgi->cmd_len == 12;
   sg_hd->result = 0;
-  sg_hd->reply_len = SG_OFF + out_size;
+  sg_hd->reply_len = SG_OFF + sgi->out_size;
 
   /* The following is one of the scariest hacks I've ever had to use.
      The idea is this: We want to know if a command fails.  The
@@ -135,8 +430,8 @@
      length for a command that doesn't take data) such that we can
      tell if the command failed.  Scared yet? */
 
-  if(bytecheck && out_size>in_size){
-    memset(d->sg_buffer+cmd_len+in_size,bytefill,out_size-in_size); 
+  if(sgi->bytecheck && out_size>in_size){
+    /* the memset for this is done in sg2_setup_scsi_cmd() */
     /* the size does not remove cmd_len due to the way the kernel
        driver copies buffers */
     writebytes+=(out_size-in_size);
@@ -224,40 +519,10 @@
     if(errno==0)errno=EIO;
     return(TR_EREAD);
   }
-
-  if(sg_hd->sense_buffer[0]){
-    char key=sg_hd->sense_buffer[2]&0xf;
-    char ASC=sg_hd->sense_buffer[12];
-    char ASCQ=sg_hd->sense_buffer[13];
-    switch(key){
-    case 0:
-      if(errno==0)errno=EIO;
-      return(TR_UNKNOWN);
-    case 1:
-      break;
-    case 2:
-      if(errno==0)errno=EBUSY;
-      return(TR_BUSY);
-    case 3: 
-      if(ASC==0x0C && ASCQ==0x09){
-	/* loss of streaming */
-	if(errno==0)errno=EIO;
-	return(TR_STREAMING);
-      }else{
-	if(errno==0)errno=EIO;
-	return(TR_MEDIUM);
-      }
-    case 4:
-      if(errno==0)errno=EIO;
-      return(TR_FAULT);
-    case 5:
-      if(errno==0)errno=EINVAL;
-      return(TR_ILLEGAL);
-    default:
-      if(errno==0)errno=EIO;
-      return(TR_UNKNOWN);
-    }
-  }
+  
+  status = check_sbp_error(sg_hd->sense_buffer);
+  if (status)
+    return status;
 
   /* still not foolproof; the following doesn't guarantee that we got
      all the data, just that the command was not rejected. */
@@ -266,10 +531,11 @@
      commands still get through.  Perhaps no data comes back even
      though the target reports success? */
 
-  if(bytecheck && in_size+cmd_len<out_size){
+  if(sgi->bytecheck && sgi->in_size+sgi->cmd_len<sgi->out_size){
     long i,flag=0;
-    for(i=in_size;i<out_size;i++)
-      if(d->sg_buffer[i]!=bytefill){
+    for(i=sgi->in_size; i<sgi->out_size; i++)
+      /* XXX check this offset */
+      if((sgi->dxferp[i])!=(sgi->bytefill)){
 	flag=1;
 	break;
       }
@@ -284,61 +550,67 @@
   return(0);
 }
 
-/* Group 1 (10b) command */
+void sg2_init_sg_info(cdrom_drive *d) {
+  struct sg_info *sgi = (struct sg_info *)d->sg;
+  struct sg_header *hdr;
 
-static int mode_sense_atapi(cdrom_drive *d,int size,int page){ 
-  memcpy(d->sg_buffer,  
-	 (char [])  {0x5A,   /* MODE_SENSE */
-		       0x00, /* reserved */
-		       0x00, /* page */
-		       0,    /* reserved */
-		       0,    /* reserved */
-		       0,    /* reserved */
-		       0,    /* reserved */
-		       0,    /* MSB (0) */
-		       0,    /* sizeof(modesense - SG_OFF) */
-		       0},   /* reserved */ 
-         10);
-
-  d->sg_buffer[1]=d->lun<<5;
-  d->sg_buffer[2]=0x3F&page;
-  d->sg_buffer[8]=size+4;
+  hdr = calloc(sizeof (struct sg_header)+sgi->dxferp_max_buffer_len, 1);
 
-  if (handle_scsi_cmd (d, 10, 0, size+4,'\377',1)) return(1);
+  sgi->cmdp = (char *)hdr + sizeof (struct sg_header);
+  sgi->cmdp_buffer_len = 0;
 
-  {
-    char *b=d->sg_buffer;
-    if(b[0])return(1); /* Handles only up to 256 bytes */
-    if(b[6])return(1); /* Handles only up to 256 bytes */
-
-    b[0]=b[1]-3;
-    b[1]=b[2];
-    b[2]=b[3];
-    b[3]=b[7];
+  sgi->bytefill = '\xff';
+  sgi->bytecheck = 1;
 
-    memmove(b+4,b+8,size);
-  }
-  return(0);
+  sgi->setup_scsi_cmd = sg2_setup_scsi_cmd;
+  sgi->handle_scsi_cmd = sg2_handle_scsi_cmd;
+
+  sg2_tweak_SG_buffer(d);
+
+  // sgi->dxferp = hdr + sizeof (struct sg_header);
+  sgi->dxferp = NULL;
+  sgi->dxferp_buffer_len = 0;
+}
+
+static int mode_sense_atapi(cdrom_drive *d, int size, int page) { 
+  char *buffer;
+
+  ((struct sg_info *)d->sg)->setup_scsi_cmd(d, SCSI_MODE_SENSE_10(page,size), 10, 0, size);
+
+  buffer = ((struct sg_info *)d->sg)->dxferp;
+#if 0
+  buffer[1]=d->lun<<5;
+#endif
+
+  if (((struct sg_info *)d->sg)->handle_scsi_cmd(d))
+    return 1;
+
+  if(buffer[0])return(1); /* Handles only up to 256 bytes */
+  if(buffer[6])return(1); /* Handles only up to 256 bytes */
+
+  buffer[0]=buffer[1]-3; 
+  buffer[1]=buffer[2];
+  buffer[2]=buffer[3];
+  buffer[3]=buffer[7];
+
+  memmove(buffer+4,buffer+8,size);
+  return 0;
 }
 
 /* group 0 (6b) command */
 
 static int mode_sense_scsi(cdrom_drive *d,int size,int page){  
-  memcpy(d->sg_buffer,  
-	 (char [])  {0x1A,   /* MODE_SENSE */
-		       0x00, /* return block descriptor/lun */
-		       0x00, /* page */
-		       0,    /* reserved */
-		       0,   /* sizeof(modesense - SG_OFF) */
-		       0},   /* control */ 
-         6);
+  char *buffer;
+  ((struct sg_info *)d->sg)->setup_scsi_cmd(d, SCSI_MODE_SENSE_6(page, size), 6, 0, size);
   
-  d->sg_buffer[1]=d->lun<<5;
-  d->sg_buffer[2]=(0x3F&page);
-  d->sg_buffer[4]=size;
-
-  if (handle_scsi_cmd (d, 6, 0, size, '\377',1)) return(1);
-  return(0);
+  buffer = ((struct sg_info *)d->sg)->dxferp;
+#if 0
+  buffer[1]=d->lun<<5;
+#endif
+
+  if (((struct sg_info *)d->sg)->handle_scsi_cmd(d))
+    return 1;
+  return 0;
 }
 
 static int mode_sense(cdrom_drive *d,int size,int page){
@@ -347,80 +619,77 @@
   return(mode_sense_scsi(d,size,page));
 }
 
-static int mode_select(cdrom_drive *d,int density,int secsize){
-  /* short circut the way Heiko does it; less flexible, but shorter */
-  if(d->is_atapi){
-    unsigned char *mode = d->sg_buffer + 18;
+static int atapi_mode_select(cdrom_drive *d, int density, int secsize) {
+  unsigned char *mode;
 
-    memcpy(d->sg_buffer,
-	   (char []) { 0x55, /* MODE_SELECT */
-			 0x10, /* no save page */
-			 0, /* reserved */
-			 0, /* reserved */
-			 0, /* reserved */
-			 0, /* reserved */
-			 0, /* reserved */
-			 0, /* reserved */
-			 12, /* sizeof(mode) */
-			 0, /* reserved */
-
-			 /* mode parameter header */
-			 0, 0, 0, 0,  0, 0, 0, 
-			 8, /* Block Descriptor Length */
-
-			 /* descriptor block */
-			 0,       /* Density Code */
-			 0, 0, 0, /* # of Blocks */
-			 0,       /* reserved */
-			 0, 0, 0},/* Blocklen */
-	   26);
-
-    d->sg_buffer[1]|=d->lun<<5;
-
-    /* prepare to read cds in the previous mode */
-    mode [0] = density;
-    mode [6] =  secsize >> 8;   /* block length "msb" */
-    mode [7] =  secsize & 0xFF; /* block length lsb */
+  ((struct sg_info *)d->sg)->setup_scsi_cmd(d, SCSI_MODE_SELECT_10, 10, 16, 0);
+  memcpy(((struct sg_info *)d->sg)->dxferp,(char []) { 
+      /* mode parameter header */
+      0, 0, 0, 0,  0, 0, 0, 
+      8,	/* Block Descriptor Length */
+      /* descriptor block */
+      0,       /* Density Code */
+      0, 0, 0, /* # of Blocks */
+      0,       /* reserved */
+      0, 0, 0},/* Blocklen */
+    16);
+
+  mode = ((struct sg_info *)d->sg)->dxferp;
+#if 0
+  mode[1] |= d->lun << 5;
+#endif
+  /* prepare to read cds in the previous mode */
+  mode[8] = density;
+  mode[14] = secsize >> 8;   /* block length "msb" */
+  mode[15] = secsize & 0xFF; /* block length lsb */
+
+  /* do the scsi cmd */
+  return ((struct sg_info *)d->sg)->handle_scsi_cmd(d);
+}
+
+static int scsi_mode_select(cdrom_drive *d, int density, int secsize) {
+  unsigned char *mode;
+
+  ((struct sg_info *)d->sg)->setup_scsi_cmd(d, SCSI_MODE_SELECT_6, 6, 12, 0);
+  memcpy(((struct sg_info *)d->sg)->dxferp,(char []) {
+      /* mode section */
+      0, 
+      0, 0, 
+      8,       /* Block Descriptor Length */
+      0,       /* Density Code */
+      0, 0, 0, /* # of Blocks */
+      0,       /* reserved */
+      0, 0, 0},/* Blocklen */
+    12);
+    
+  /* prepare to read cds in the previous mode */
+  mode = ((struct sg_info *)d->sg)->dxferp;
+  mode [4] = density;
+  mode [10] =  secsize >> 8;   /* block length "msb" */
+  mode [11] =  secsize & 0xFF; /* block length lsb */
 
     /* do the scsi cmd */
-    return(handle_scsi_cmd (d,10, 16, 0,0,0));
-
-  }else{
-    unsigned char *mode = d->sg_buffer + 10;
-
-    memcpy(d->sg_buffer,
-	   (char []) { 0x15, /* MODE_SELECT */
-			 0x10, /* no save page */
-			 0, /* reserved */
-			 0, /* reserved */
-			 12, /* sizeof(mode) */
-			 0, /* reserved */
-			 /* mode section */
-			 0, 
-			 0, 0, 
-			 8,       /* Block Descriptor Length */
-			 0,       /* Density Code */
-			 0, 0, 0, /* # of Blocks */
-			 0,       /* reserved */
-			 0, 0, 0},/* Blocklen */
-	   18);
-
-    /* prepare to read cds in the previous mode */
-    mode [0] = density;
-    mode [6] =  secsize >> 8;   /* block length "msb" */
-    mode [7] =  secsize & 0xFF; /* block length lsb */
+  return ((struct sg_info *)d->sg)->handle_scsi_cmd(d);
+}
 
-    /* do the scsi cmd */
-    return(handle_scsi_cmd (d,6, 12, 0,0,0));
-  }
+static int mode_select(cdrom_drive *d, int density, int secsize) {
+  /* short circut the way Heiko does it; less flexible, but shorter */
+  if (d->is_atapi)
+    return atapi_mode_select(d, density, secsize);
+  return scsi_mode_select(d, density, secsize);
 }
 
 /* get current sector size from SCSI cdrom drive */
 static unsigned int get_orig_sectorsize(cdrom_drive *d){
-  if(mode_sense(d,12,0x01))return(-1);
+  if (mode_sense(d,12,0x01))
+    return -1;
+
+  d->orgdens = ((struct sg_info *)d->sg)->dxferp[4];
+  
+  d->orgsize = (int)(((struct sg_info *)d->sg)->dxferp[10]<<8);
+  d->orgsize += (int)((struct sg_info *)d->sg)->dxferp[11];
 
-  d->orgdens = d->sg_buffer[4];
-  return(d->orgsize = ((int)(d->sg_buffer[10])<<8)+d->sg_buffer[11]);
+  return d->orgsize;
 }
 
 /* switch CDROM scsi drives to given sector size  */
@@ -463,23 +732,23 @@
    fails on at least one Kodak drive. */
 
 static int scsi_read_toc (cdrom_drive *d){
+  struct sg_info *sgi = (struct sg_info *)d->sg;
   int i,first,last;
   unsigned tracks;
-
-  /* READTOC, MSF format flag, res, res, res, res, Start track, len msb,
-     len lsb, flags */
+  scsi_TOC *toc;
 
   /* read the header first */
-  memcpy(d->sg_buffer, (char []){ 0x43, 0, 0, 0, 0, 0, 1, 0, 12, 0}, 10);
-  d->sg_buffer[1]=d->lun<<5;
-
-  if (handle_scsi_cmd (d,10, 0, 12,'\377',1)){
+  sgi->setup_scsi_cmd(d, SCSI_READ_TOC(1), 10, 0, 12);
+#if 0
+  sgi->dxferp[1] = d->lun << 5;
+#endif
+  if (sgi->handle_scsi_cmd(d)) {
     cderror(d,"004: Unable to read table of contents header\n");
     return(-4);
   }
 
-  first=d->sg_buffer[2];
-  last=d->sg_buffer[3];
+  first = sgi->dxferp[2];
+  last = sgi->dxferp[3];
   tracks=last-first+1;
 
   if (last > MAXTRK || first > MAXTRK || last<0 || first<0) {
@@ -488,335 +757,208 @@
   }
 
   for (i = first; i <= last; i++){
-    memcpy(d->sg_buffer, (char []){ 0x43, 0, 0, 0, 0, 0, 0, 0, 12, 0}, 10);
-    d->sg_buffer[1]=d->lun<<5;
-    d->sg_buffer[6]=i;
+    sgi->setup_scsi_cmd(d, SCSI_READ_TOC(i), 10, 0, 12);
+#if 0    
+    sgi->dxferp[1] = d->lun << 5;
+#endif
     
-    if (handle_scsi_cmd (d,10, 0, 12,'\377',1)){
+    if (sgi->handle_scsi_cmd(d)) {
       cderror(d,"005: Unable to read table of contents entry\n");
       return(-5);
     }
-    {
-      scsi_TOC *toc=(scsi_TOC *)(d->sg_buffer+4);
-
-      d->disc_toc[i-first].bFlags=toc->bFlags;
-      d->disc_toc[i-first].bTrack=i;
-      d->disc_toc[i-first].dwStartSector= d->adjust_ssize * 
-	(((int)(toc->start_MSB)<<24) | 
-	 (toc->start_1<<16)|
-	 (toc->start_2<<8)|
-	 (toc->start_LSB));
-    }
-  }
+    toc = (scsi_TOC *)(sgi->dxferp+4);
+    d->disc_toc[i-first].bFlags = toc->bFlags;
+    d->disc_toc[i-first].bTrack = i;
+    d->disc_toc[i-first].dwStartSector = 
+      d->adjust_ssize * (
+        ((int)(toc->start_MSB)<<24) | (toc->start_1 << 16) |
+        (toc->start_2 << 8) | (toc->start_LSB)
+      );
+  }
+
+  sgi->setup_scsi_cmd(d, SCSI_READ_TOC(0xAA), 10, 0, 12);
+#if 0    
+  sgi->dxferp[1] = d->lun << 5;
+#endif
 
-  memcpy(d->sg_buffer, (char []){ 0x43, 0, 0, 0, 0, 0, 0, 0, 12, 0}, 10);
-  d->sg_buffer[1]=d->lun<<5;
-  d->sg_buffer[6]=0xAA;
-    
-  if (handle_scsi_cmd (d,10, 0, 12,'\377',1)){
+  if (sgi->handle_scsi_cmd(d)) {
     cderror(d,"002: Unable to read table of contents lead-out\n");
     return(-2);
   }
-  {
-    scsi_TOC *toc=(scsi_TOC *)(d->sg_buffer+4);
-    
-    d->disc_toc[i-first].bFlags=toc->bFlags;
-    d->disc_toc[i-first].bTrack=0xAA;
-    d->disc_toc[i-first].dwStartSector= d->adjust_ssize * 
-	(((int)(toc->start_MSB)<<24) | 
-	 (toc->start_1<<16)|
-	 (toc->start_2<<8)|
-	 (toc->start_LSB));
-  }
+  
+  toc = (scsi_TOC *)(sgi->dxferp+4);
+  d->disc_toc[i-first].bFlags = toc->bFlags;
+  d->disc_toc[i-first].bTrack = 0xAA;
+  d->disc_toc[i-first].dwStartSector = 
+    d->adjust_ssize * (
+      ((int)(toc->start_MSB)<<24) | (toc->start_1 << 16) |
+      (toc->start_2 << 8) | (toc->start_LSB)
+    );
 
   d->cd_extra = FixupTOC(d,tracks+1); /* include lead-out */
-  return(tracks);
+  return tracks;
 }
 
 /* a contribution from Boris for IMS cdd 522 */
 /* check this for ACER/Creative/Foo 525,620E,622E, etc? */
 static int scsi_read_toc2 (cdrom_drive *d){
-  u_int32_t foo,bar;
+  struct sg_info *sgi = (struct sg_info *)d->sg;
+  u_int32_t msb,lsb;
 
   int i;
   unsigned tracks;
 
-  memcpy(d->sg_buffer, (char[]){ 0xe5, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 10);
-  d->sg_buffer[5]=1;
-  d->sg_buffer[8]=255;
-
-  if (handle_scsi_cmd (d,10, 0, 256,'\377',1)){
+  sgi->setup_scsi_cmd(d, CDD522_READ_TOC(1), 10, 0, 256);
+  if (sgi->handle_scsi_cmd(d)) {
     cderror(d,"004: Unable to read table of contents header\n");
     return(-4);
   }
 
   /* copy to our structure and convert start sector */
-  tracks = d->sg_buffer[1];
+  tracks = sgi->dxferp[1];
   if (tracks > MAXTRK) {
     cderror(d,"003: CDROM reporting illegal number of tracks\n");
     return(-3);
   }
 
   for (i = 0; i < tracks; i++){
-    memcpy(d->sg_buffer, (char[]){ 0xe5, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 10);
-    d->sg_buffer[5]=i+1;
-    d->sg_buffer[8]=255;
+    sgi->setup_scsi_cmd(d, CDD522_READ_TOC(i+1), 10, 0, 256);
     
-    if (handle_scsi_cmd (d,10, 0, 256,'\377',1)){
+    if (sgi->handle_scsi_cmd(d)) {
       cderror(d,"005: Unable to read table of contents entry\n");
       return(-5);
     }
     
-    d->disc_toc[i].bFlags = d->sg_buffer[10];
+    d->disc_toc[i].bFlags = sgi->dxferp[10];
     d->disc_toc[i].bTrack = i + 1;
 
-    d->disc_toc[i].dwStartSector= d->adjust_ssize * 
-	(((signed char)(d->sg_buffer[2])<<24) | 
-	 (d->sg_buffer[3]<<16)|
-	 (d->sg_buffer[4]<<8)|
-	 (d->sg_buffer[5]));
+    d->disc_toc[i].dwStartSector = d->adjust_ssize * (
+        ((signed char)(sgi->dxferp[2])<<24) | 
+	(sgi->dxferp[3]<<16) |
+	(sgi->dxferp[4]<<8) |
+	(sgi->dxferp[5])
+      );
   }
 
   d->disc_toc[i].bFlags = 0;
   d->disc_toc[i].bTrack = i + 1;
-  memcpy (&foo, d->sg_buffer+2, 4);
-  memcpy (&bar, d->sg_buffer+6, 4);
-  d->disc_toc[i].dwStartSector = d->adjust_ssize * (be32_to_cpu(foo) +
-						    be32_to_cpu(bar));
-
-  d->disc_toc[i].dwStartSector= d->adjust_ssize * 
-    ((((signed char)(d->sg_buffer[2])<<24) | 
-      (d->sg_buffer[3]<<16)|
-      (d->sg_buffer[4]<<8)|
-      (d->sg_buffer[5]))+
-     
-     ((((signed char)(d->sg_buffer[6])<<24) | 
-       (d->sg_buffer[7]<<16)|
-       (d->sg_buffer[8]<<8)|
-       (d->sg_buffer[9]))));
-
+  memcpy (&msb, sgi->dxferp+2, 4);
+  memcpy (&lsb, sgi->dxferp+6, 4);
+  d->disc_toc[i].dwStartSector = d->adjust_ssize *
+      (be32_to_cpu(msb) + be32_to_cpu(lsb));
+
+  d->disc_toc[i].dwStartSector= d->adjust_ssize * (
+    ((((signed char)(sgi->dxferp[2])<<24) | 
+        (sgi->dxferp[3]<<16) |
+        (sgi->dxferp[4]<<8) |
+        (sgi->dxferp[5])
+      ) + (
+        ((signed char)(sgi->dxferp[6])<<24) | 
+        (sgi->dxferp[7]<<16) |
+        (sgi->dxferp[8]<<8) |
+        (sgi->dxferp[9])))
+    );
 
   d->cd_extra = FixupTOC(d,tracks+1);
-  return(tracks);
+  return tracks;
 }
 
 /* These do one 'extra' copy in the name of clean code */
 
-static int i_read_28 (cdrom_drive *d, void *p, long begin, long sectors){
+static int generic_scsi_read(cdrom_drive *d, void *p, long begin, long sectors,
+    char *read_cmd, int len, int in_size, int out_size) {
+  struct sg_info *sgi = (struct sg_info *)d->sg;
   int ret;
-  memcpy(d->sg_buffer,(char []){0x28, 0, 0, 0, 0, 0, 0, 0, 0, 0},10);
-
-  if(d->fua)
-    d->sg_buffer[1]=0x08;
 
-  d->sg_buffer[1]|=d->lun<<5;
+  sgi->setup_scsi_cmd(d, read_cmd, len, in_size, out_size);
+#if 0    
+  sgi->dxferp[1] = d->lun << 5;
+#endif
 
-  d->sg_buffer[3] = (begin >> 16) & 0xFF;
-  d->sg_buffer[4] = (begin >> 8) & 0xFF;
-  d->sg_buffer[5] = begin & 0xFF;
-  d->sg_buffer[8] = sectors;
-  if((ret=handle_scsi_cmd(d,10,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+  ret = sgi->handle_scsi_cmd(d);
+  if (ret)
+    return ret;
+  if (p)
+    memcpy(p, sgi->dxferp, sectors * CD_FRAMESIZE_RAW);
+  return 0;
 }
 
-static int i_read_A8 (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  memcpy(d->sg_buffer,(char []){0xA8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},12);
-
-  if(d->fua)
-    d->sg_buffer[1]=0x08;
-
-  d->sg_buffer[1]|=d->lun<<5;
-
-  d->sg_buffer[3] = (begin >> 16) & 0xFF;
-  d->sg_buffer[4] = (begin >> 8) & 0xFF;
-  d->sg_buffer[5] = begin & 0xFF;
-  d->sg_buffer[9] = sectors;
-  if((ret=handle_scsi_cmd(d,12,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+static int i_read_28(cdrom_drive *d, void *p, long begin, long sectors){
+  return generic_scsi_read(d, p, begin, sectors,
+    SCSI_READ_10(d->fua, begin, sectors), 10, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
-static int i_read_D4_10 (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  memcpy(d->sg_buffer,(char []){0xd4, 0, 0, 0, 0, 0, 0, 0, 0, 0},10);
-
-  if(d->fua)
-    d->sg_buffer[1]=0x08;
-
-  d->sg_buffer[1]|=d->lun<<5;
-  d->sg_buffer[3] = (begin >> 16) & 0xFF;
-  d->sg_buffer[4] = (begin >> 8) & 0xFF;
-  d->sg_buffer[5] = begin & 0xFF;
-  d->sg_buffer[8] = sectors;
-  if((ret=handle_scsi_cmd(d,10,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+static int i_read_A8(cdrom_drive *d, void *p, long begin, long sectors){
+  return generic_scsi_read(d, p, begin, sectors,
+    SCSI_READ_12(d->fua, begin, sectors), 12, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
-static int i_read_D4_12 (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  memcpy(d->sg_buffer,(char []){0xd4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},12);
-
-  if(d->fua)
-    d->sg_buffer[1]=0x08;
-
-  d->sg_buffer[1]|=d->lun<<5;
-  d->sg_buffer[3] = (begin >> 16) & 0xFF;
-  d->sg_buffer[4] = (begin >> 8) & 0xFF;
-  d->sg_buffer[5] = begin & 0xFF;
-  d->sg_buffer[9] = sectors;
-  if((ret=handle_scsi_cmd(d,12,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+static int i_read_D4_10(cdrom_drive *d, void *p, long begin, long sectors){
+  return generic_scsi_read(d, p, begin, sectors,
+    D4_READ_10(begin, sectors), 10, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
-static int i_read_D5 (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  memcpy(d->sg_buffer,(char []){0xd5, 0, 0, 0, 0, 0, 0, 0, 0, 0},10);
-
-  if(d->fua)
-    d->sg_buffer[1]=0x08;
-
-  d->sg_buffer[1]|=d->lun<<5;
-  d->sg_buffer[3] = (begin >> 16) & 0xFF;
-  d->sg_buffer[4] = (begin >> 8) & 0xFF;
-  d->sg_buffer[5] = begin & 0xFF;
-  d->sg_buffer[8] = sectors;
-  if((ret=handle_scsi_cmd(d,10,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+static int i_read_D4_12(cdrom_drive *d, void *p, long begin, long sectors){
+  return generic_scsi_read(d, p, begin, sectors,
+    D4_READ_12(begin, sectors), 12, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
-static int i_read_D8 (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  memcpy(d->sg_buffer,(char []){0xd8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},12);
-
-  if(d->fua)
-    d->sg_buffer[1]=0x08;
-
-  d->sg_buffer[1]|=d->lun<<5;
-  d->sg_buffer[3] = (begin >> 16) & 0xFF;
-  d->sg_buffer[4] = (begin >> 8) & 0xFF;
-  d->sg_buffer[5] = begin & 0xFF;
-  d->sg_buffer[9] = sectors;
-  if((ret=handle_scsi_cmd(d,12,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+static int i_read_D5(cdrom_drive *d, void *p, long begin, long sectors){
+  return generic_scsi_read(d, p, begin, sectors,
+    D5_READ_10(begin, sectors), 10, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
-static int i_read_mmc (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  /*  if(begin<=12007 && begin+sectors>12000){
-    errno=EIO;
-    return(TR_ILLEGAL);
-  }*/
-
-  memcpy(d->sg_buffer,(char []){0xbe, 0, 0, 0, 0, 0, 0, 0, 0, 0x10, 0, 0},12);
-
-  d->sg_buffer[3] = (begin >> 16) & 0xFF;
-  d->sg_buffer[4] = (begin >> 8) & 0xFF;
-  d->sg_buffer[5] = begin & 0xFF;
-  d->sg_buffer[8] = sectors;
-  if((ret=handle_scsi_cmd(d,12,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+static int i_read_D8(cdrom_drive *d, void *p, long begin, long sectors){
+  return generic_scsi_read(d, p, begin, sectors,
+    D8_READ_12(begin, sectors), 12, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
-static int i_read_mmc2 (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  memcpy(d->sg_buffer,(char []){0xbe, 0, 0, 0, 0, 0, 0, 0, 0, 0xf8, 0, 0},12);
-
-  d->sg_buffer[3] = (begin >> 16) & 0xFF;
-  d->sg_buffer[4] = (begin >> 8) & 0xFF;
-  d->sg_buffer[5] = begin & 0xFF;
-  d->sg_buffer[8] = sectors;
-  if((ret=handle_scsi_cmd(d,12,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+static int i_read_mmc(cdrom_drive *d, void *p, long begin, long sectors){
+  return generic_scsi_read(d, p, begin, sectors,
+    READ_CD_12(begin, sectors), 12, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
-static int i_read_mmc3 (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  memcpy(d->sg_buffer,(char []){0xbe, 4, 0, 0, 0, 0, 0, 0, 0, 0xf8, 0, 0},12);
+static int i_read_mmc2(cdrom_drive *d, void *p, long begin, long sectors){
+  char cmd[12];
 
-  d->sg_buffer[3] = (begin >> 16) & 0xFF;
-  d->sg_buffer[4] = (begin >> 8) & 0xFF;
-  d->sg_buffer[5] = begin & 0xFF;
-  d->sg_buffer[8] = sectors;
-  if((ret=handle_scsi_cmd(d,12,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+  memcpy(cmd, READ_CD_12(begin, sectors), 12);
+  cmd[9] = 0xf8;
+  return generic_scsi_read(d, p, begin, sectors,
+    cmd, 12, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
-/* straight from the MMC3 spec */
-static inline void LBA_to_MSF(long lba,
-			      unsigned char *M, 
-			      unsigned char *S, 
-			      unsigned char *F){
-  if(lba>=-150){
-    *M=(lba+150)/(60*75);
-    lba-=(*M)*60*75;
-    *S=(lba+150)/75;
-    lba-=(*S)*75;
-    *F=(lba+150);
-  }else{
-    *M=(lba+450150)/(60*75);
-    lba-=(*M)*60*75;
-    *S=(lba+450150)/75;
-    lba-=(*S)*75;
-    *F=(lba+450150);
-  }
-}
-
-
-static int i_read_msf (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  memcpy(d->sg_buffer,(char []){0xb9, 0, 0, 0, 0, 0, 0, 0, 0, 0x10, 0, 0},12);
+static int i_read_mmc3(cdrom_drive *d, void *p, long begin, long sectors){
+  char cmd[12];
 
-  LBA_to_MSF(begin,d->sg_buffer+3,d->sg_buffer+4,d->sg_buffer+5);
-  LBA_to_MSF(begin+sectors,d->sg_buffer+6,d->sg_buffer+7,d->sg_buffer+8);
+  memcpy(cmd, READ_CD_12(begin, sectors), 12);
+  cmd[1] = 4;  
+  cmd[9] = 0xf8;
+  return generic_scsi_read(d, p, begin, sectors,
+    cmd, 12, 0, sectors * CD_FRAMESIZE_RAW);
+}
 
-  if((ret=handle_scsi_cmd(d,12,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+static int i_read_msf(cdrom_drive *d, void *p, long begin, long sectors){
+  return generic_scsi_read(d, p, begin, sectors,
+    READ_CD_MSF_12(begin, sectors), 12, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
 static int i_read_msf2 (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  memcpy(d->sg_buffer,(char []){0xb9, 0, 0, 0, 0, 0, 0, 0, 0, 0xf8, 0, 0},12);
+  char cmd[12];
 
-  LBA_to_MSF(begin,d->sg_buffer+3,d->sg_buffer+4,d->sg_buffer+5);
-  LBA_to_MSF(begin+sectors,d->sg_buffer+6,d->sg_buffer+7,d->sg_buffer+8);
-
-  if((ret=handle_scsi_cmd(d,12,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+  memcpy(cmd, READ_CD_MSF_12(begin, sectors), 12);
+  cmd[9] = 0xf8;
+  return generic_scsi_read(d, p, begin, sectors,
+    cmd, 12, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
 static int i_read_msf3 (cdrom_drive *d, void *p, long begin, long sectors){
-  int ret;
-  memcpy(d->sg_buffer,(char []){0xb9, 4, 0, 0, 0, 0, 0, 0, 0, 0xf8, 0, 0},12);
+  char cmd[12];
 
-  LBA_to_MSF(begin,d->sg_buffer+3,d->sg_buffer+4,d->sg_buffer+5);
-  LBA_to_MSF(begin+sectors,d->sg_buffer+6,d->sg_buffer+7,d->sg_buffer+8);
-
-  if((ret=handle_scsi_cmd(d,12,0,sectors * CD_FRAMESIZE_RAW,'\177',1)))
-    return(ret);
-  if(p)memcpy(p,d->sg_buffer,sectors*CD_FRAMESIZE_RAW);
-  return(0);
+  memcpy(cmd, READ_CD_MSF_12(begin, sectors), 12);
+  cmd[1] = 4;
+  cmd[9] = 0xf8;
+  return generic_scsi_read(d, p, begin, sectors,
+    cmd, 12, 0, sectors * CD_FRAMESIZE_RAW);
 }
 
 static long scsi_read_map (cdrom_drive *d, void *p, long begin, long sectors,
@@ -824,6 +966,10 @@
   int retry_count,err;
   char *buffer=(char *)p;
 
+  struct sg_info *sgi = (struct sg_info *)d->sg;
+  struct sg_io_hdr *hdr = sgi->hdr;
+  unsigned char key, ASC, ASCQ;
+
   /* read d->nsectors at a time, max. */
   sectors=(sectors>d->nsectors?d->nsectors:sectors);
   sectors=(sectors<1?1:sectors);
@@ -832,17 +978,32 @@
   
   while(1) {
     if((err=map(d,(p?buffer:NULL),begin,sectors))){
+      /* Dunno if we even need this now that scsi_reset does it,
+       * but try to take "device is becoming ready" into account */
+      key = hdr->sbp[2] & 0xf;
+      ASC = hdr->sbp[12];
+      ASCQ = hdr->sbp[13];
+
+      if(key == 2 & ASC == 4 & ASCQ == 1) {
+        if(retry_count > MAX_RETRIES-1) {
+	  char b[256];
+	  sprintf(b,"010: Unable to access sector %ld\n",
+	    begin);
+	  cderror(d,b);
+	  return(-10);
+	} else {
+	  retry_count++;
+	  usleep(100);
+	  continue;
+	}
+      }
       if(d->report_all){
-	struct sg_header *sg_hd=(struct sg_header *)d->sg;
 	char b[256];
-
 	sprintf(b,"scsi_read error: sector=%ld length=%ld retry=%d\n",
 		begin,sectors,retry_count);
 	cdmessage(d,b);
 	sprintf(b,"                 Sense key: %x ASC: %x ASCQ: %x\n",
-		(int)(sg_hd->sense_buffer[2]&0xf),
-		(int)(sg_hd->sense_buffer[12]),
-		(int)(sg_hd->sense_buffer[13]));
+		key, ASC, ASCQ);
 	cdmessage(d,b);
 	sprintf(b,"                 Transport error: %s\n",strerror_tr[err]);
 	cdmessage(d,b);
@@ -852,9 +1013,7 @@
 	fprintf(stderr,"scsi_read error: sector=%ld length=%ld retry=%d\n",
 		begin,sectors,retry_count);
 	fprintf(stderr,"                 Sense key: %x ASC: %x ASCQ: %x\n",
-		(int)(sg_hd->sense_buffer[2]&0xf),
-		(int)(sg_hd->sense_buffer[12]),
-		(int)(sg_hd->sense_buffer[13]));
+		key, ASC, ASCQ);
 	fprintf(stderr,"                 Transport error: %s\n",strerror_tr[err]);
 	fprintf(stderr,"                 System error: %s\n",strerror(errno));
       }
@@ -1014,7 +1173,7 @@
 static int count_2352_bytes(cdrom_drive *d){
   long i;
   for(i=2351;i>=0;i--)
-    if(d->sg_buffer[i]!=(unsigned char)'\177')
+    if(((struct sg_info *)d->sg)->dxferp[i]!=(unsigned char)'\177')
       return(((i+3)>>2)<<2);
 
   return(0);
@@ -1023,7 +1182,7 @@
 static int verify_nonzero(cdrom_drive *d){
   long i,flag=0;
   for(i=0;i<2352;i++)
-    if(d->sg_buffer[i]!=0){
+    if(((struct sg_info *)d->sg)->dxferp[i]!=0){
       flag=1;
       break;
     }
@@ -1307,7 +1466,17 @@
   return;
 }
 
-static int check_atapi(cdrom_drive *d){
+static int check_sgio(cdrom_drive *d) {
+  int fd = d->cdda_fd;
+
+#ifdef SG_IO
+  if (fd == check_fd_sgio(fd))
+    return 1;
+#endif
+  return 0;
+}
+
+static int check_atapi(cdrom_drive *d, int using_sgio){
   int atapiret=-1;
   int fd = d->cdda_fd; /* this is the correct fd (not ioctl_fd), as the 
 			  generic device is the device we need to check */
@@ -1321,7 +1490,7 @@
     if(atapiret==1){
       cdmessage(d,"\tDrive is ATAPI (using SCSI host adaptor emulation)\n");
       /* Disable kernel SCSI command translation layer for access through sg */
-      if (ioctl(fd,SG_SET_TRANSFORM,0))
+      if (!using_sgio && ioctl(fd,SG_SET_TRANSFORM,0))
 	cderror(d,"\tCouldn't disable kernel command translation layer\n");
       d->is_atapi=1;
     }else{
@@ -1340,7 +1509,7 @@
   d->is_mmc=0;
   if(mode_sense(d,22,0x2A)==0){
   
-    b=d->sg_buffer;
+    b=((struct sg_info *)d->sg)->dxferp;
     b+=b[3]+4;
     
     if((b[0]&0x3F)==0x2A){
@@ -1380,21 +1549,27 @@
 }
 
 /* request vendor brand and model */
-unsigned char *scsi_inquiry(cdrom_drive *d){
-  memcpy(d->sg_buffer,(char[]){ 0x12,0,0,0,56,0},6);
+unsigned char *scsi_inquiry(cdrom_drive *d) {
+  static char ret[56];
+  struct sg_info *sgi = (struct sg_info *)d->sg;
 
-  if(handle_scsi_cmd(d,6, 0, 56,'\377',1)) {
+  if (sgi->hdr == NULL)
+    scsi_init_drive(d);
+
+  sgi->setup_scsi_cmd(d, SCSI_INQUIRY_6(56), 6, 0, 56);
+  if (sgi->handle_scsi_cmd(d)) {
     cderror(d,"008: Unable to identify CDROM model\n");
-    return(NULL);
+    return NULL;
   }
-  return (d->sg_buffer);
+  memcpy(ret, ((struct sg_info *)d->sg)->dxferp, 56);
+  return ret;
 }
 
-
 int scsi_init_drive(cdrom_drive *d){
-  int ret;
+  int ret, is_sgio;
 
-  check_atapi(d);
+  is_sgio = check_sgio(d);
+  check_atapi(d, is_sgio);
   check_mmc(d);
 
   /* generic Sony type defaults; specialize from here */
@@ -1451,15 +1626,16 @@
   if(d->tracks<1)
     return(d->tracks);
 
-  tweak_SG_buffer(d);
   d->opened=1;
 
   if((ret=verify_read_command(d)))return(ret);
   check_fua_bit(d);
 
   d->error_retry=1;
-  d->sg=realloc(d->sg,d->nsectors*CD_FRAMESIZE_RAW + SG_OFF + 128);
-  d->sg_buffer=d->sg+SG_OFF;
+#if 0
+  ((struct sg_info *)d->sg)=realloc(((struct sg_info *)d->sg),d->nsectors*CD_FRAMESIZE_RAW + SG_OFF + 128);
+  ((struct sg_info *)d->sg)_buffer=((struct sg_info *)d->sg)+SG_OFF;
+#endif
   d->report_all=1;
   return(0);
 }
diff -Naur cdparanoia-III-alpha9.8.orig/interface/utils.h cdparanoia-III-alpha9.8/interface/utils.h
--- cdparanoia-III-alpha9.8.orig/interface/utils.h	2000-04-19 15:41:04.000000000 -0700
+++ cdparanoia-III-alpha9.8/interface/utils.h	2006-07-19 15:19:16.000000000 -0700
@@ -110,8 +110,6 @@
     case CDDA_MESSAGE_LOGIT:
       d->errorbuf=catstring(d->errorbuf,s);
       break;
-    case CDDA_MESSAGE_FORGETIT:
-    default:
     }
   }
 }
@@ -125,8 +123,6 @@
     case CDDA_MESSAGE_LOGIT:
       d->messagebuf=catstring(d->messagebuf,s);
       break;
-    case CDDA_MESSAGE_FORGETIT:
-    default:
     }
   }
 }
@@ -167,8 +163,6 @@
 	}
       }
       break;
-    case CDDA_MESSAGE_FORGETIT:
-    default:
     }
   }
   if(malloced)free(buffer);
@@ -203,8 +197,6 @@
 	if(!malloced)*messages=catstring(*messages,"\n");
 	}
       break;
-    case CDDA_MESSAGE_FORGETIT:
-    default:
     }
   }
   if(malloced)free(buffer);
diff -Naur cdparanoia-III-alpha9.8.orig/interface/utils.h~ cdparanoia-III-alpha9.8/interface/utils.h~
--- cdparanoia-III-alpha9.8.orig/interface/utils.h~	1969-12-31 16:00:00.000000000 -0800
+++ cdparanoia-III-alpha9.8/interface/utils.h~	2006-07-19 15:18:10.000000000 -0700
@@ -0,0 +1,212 @@
+#include <endian.h>
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+
+/* I wonder how many alignment issues this is gonna trip in the
+   future...  it shouldn't trip any...  I guess we'll find out :) */
+
+static inline int bigendianp(void){
+  int test=1;
+  char *hack=(char *)(&test);
+  if(hack[0])return(0);
+  return(1);
+}
+
+static inline int32_t swap32(int32_t x){
+  return((((u_int32_t)x & 0x000000ffU) << 24) | 
+	 (((u_int32_t)x & 0x0000ff00U) <<  8) | 
+	 (((u_int32_t)x & 0x00ff0000U) >>  8) | 
+	 (((u_int32_t)x & 0xff000000U) >> 24));
+}
+
+static inline int16_t swap16(int16_t x){
+  return((((u_int16_t)x & 0x00ffU) <<  8) | 
+	 (((u_int16_t)x & 0xff00U) >>  8));
+}
+
+#if BYTE_ORDER == LITTLE_ENDIAN
+
+static inline int32_t be32_to_cpu(int32_t x){
+  return(swap32(x));
+}
+
+static inline int16_t be16_to_cpu(int16_t x){
+  return(swap16(x));
+}
+
+static inline int32_t le32_to_cpu(int32_t x){
+  return(x);
+}
+
+static inline int16_t le16_to_cpu(int16_t x){
+  return(x);
+}
+
+#else
+
+static inline int32_t be32_to_cpu(int32_t x){
+  return(x);
+}
+
+static inline int16_t be16_to_cpu(int16_t x){
+  return(x);
+}
+
+static inline int32_t le32_to_cpu(int32_t x){
+  return(swap32(x));
+}
+
+static inline int16_t le16_to_cpu(int16_t x){
+  return(swap16(x));
+}
+
+
+#endif
+
+static inline int32_t cpu_to_be32(int32_t x){
+  return(be32_to_cpu(x));
+}
+
+static inline int32_t cpu_to_le32(int32_t x){
+  return(le32_to_cpu(x));
+}
+
+static inline int16_t cpu_to_be16(int16_t x){
+  return(be16_to_cpu(x));
+}
+
+static inline int16_t cpu_to_le16(int16_t x){
+  return(le16_to_cpu(x));
+}
+
+static inline char *copystring(const char *s){
+  if(s){
+    char *ret=malloc((strlen(s)+9)*sizeof(char)); /* +9 to get around a linux
+						     libc 5 bug. below too */
+    strcpy(ret,s);
+    return(ret);
+  }
+  return(NULL);
+}
+
+static inline char *catstring(char *buff,const char *s){
+  if(s){
+    if(buff)
+      buff=realloc(buff,strlen(buff)+strlen(s)+9);
+    else
+      buff=calloc(strlen(s)+9,1);
+    strcat(buff,s);
+  }
+  return(buff);
+}
+
+static void cderror(cdrom_drive *d,const char *s){
+  if(s && d){
+    switch(d->errordest){
+    case CDDA_MESSAGE_PRINTIT:
+      write(STDERR_FILENO,s,strlen(s));
+      break;
+    case CDDA_MESSAGE_LOGIT:
+      d->errorbuf=catstring(d->errorbuf,s);
+      break;
+    case CDDA_MESSAGE_FORGETIT:
+    default:
+    }
+  }
+}
+
+static void cdmessage(cdrom_drive *d,const char *s){
+  if(s && d){
+    switch(d->messagedest){
+    case CDDA_MESSAGE_PRINTIT:
+      write(STDERR_FILENO,s,strlen(s));
+      break;
+    case CDDA_MESSAGE_LOGIT:
+      d->messagebuf=catstring(d->messagebuf,s);
+      break;
+    case CDDA_MESSAGE_FORGETIT:
+    default:
+    }
+  }
+}
+
+static void idperror(int messagedest,char **messages,const char *f,
+		      const char *s){
+
+  char *buffer;
+  int malloced=0;
+  if(!f)
+    buffer=(char *)s;
+  else
+    if(!s)
+      buffer=(char *)f;
+    else{
+      buffer=malloc(strlen(f)+strlen(s)+9);
+      sprintf(buffer,f,s);
+      malloced=1;
+    }
+
+  if(buffer){
+    switch(messagedest){
+    case CDDA_MESSAGE_PRINTIT:
+      write(STDERR_FILENO,buffer,strlen(buffer));
+      if(errno){
+	write(STDERR_FILENO,": ",2);
+	write(STDERR_FILENO,strerror(errno),strlen(strerror(errno)));
+	write(STDERR_FILENO,"\n",1);
+      }
+      break;
+    case CDDA_MESSAGE_LOGIT:
+      if(messages){
+	*messages=catstring(*messages,buffer);
+	if(errno){
+	  *messages=catstring(*messages,": ");
+	  *messages=catstring(*messages,strerror(errno));
+	  *messages=catstring(*messages,"\n");
+	}
+      }
+      break;
+    case CDDA_MESSAGE_FORGETIT:
+    default:
+    }
+  }
+  if(malloced)free(buffer);
+}
+
+
+static void idmessage(int messagedest,char **messages,const char *f,
+		      const char *s){
+  char *buffer;
+  int malloced=0;
+  if(!f)
+    buffer=(char *)s;
+  else
+    if(!s)
+      buffer=(char *)f;
+    else{
+      buffer=malloc(strlen(f)+strlen(s)+10);
+      sprintf(buffer,f,s);
+      strcat(buffer,"\n");
+      malloced=1;
+    }
+
+  if(buffer){
+    switch(messagedest){
+    case CDDA_MESSAGE_PRINTIT:
+      write(STDERR_FILENO,buffer,strlen(buffer));
+      if(!malloced)write(STDERR_FILENO,"\n",1);
+      break;
+    case CDDA_MESSAGE_LOGIT:
+      if(messages){
+	*messages=catstring(*messages,buffer);
+	if(!malloced)*messages=catstring(*messages,"\n");
+	}
+      break;
+    case CDDA_MESSAGE_FORGETIT:
+    default:
+    }
+  }
+  if(malloced)free(buffer);
+}
+
diff -Naur cdparanoia-III-alpha9.8.orig/main.c cdparanoia-III-alpha9.8/main.c
--- cdparanoia-III-alpha9.8.orig/main.c	2001-03-25 19:44:50.000000000 -0800
+++ cdparanoia-III-alpha9.8/main.c	2006-07-19 15:16:01.000000000 -0700
@@ -851,7 +851,7 @@
   if(verbose)
     cdda_verbose_set(d,CDDA_MESSAGE_PRINTIT,CDDA_MESSAGE_PRINTIT);
   else
-    cdda_verbose_set(d,CDDA_MESSAGE_PRINTIT,CDDA_MESSAGE_FORGETIT);
+    cdda_verbose_set(d,CDDA_MESSAGE_FORGETIT,CDDA_MESSAGE_FORGETIT);
 
   /* possibly force hand on endianness of drive, sector request size */
   if(force_cdrom_endian!=-1){
@@ -1032,10 +1032,12 @@
       paranoia_modeset(p,paranoia_mode);
       if(force_cdrom_overlap!=-1)paranoia_overlapset(p,force_cdrom_overlap);
 
+#if 0
       if(verbose)
 	cdda_verbose_set(d,CDDA_MESSAGE_LOGIT,CDDA_MESSAGE_LOGIT);
       else
 	cdda_verbose_set(d,CDDA_MESSAGE_FORGETIT,CDDA_MESSAGE_FORGETIT);
+#endif
       
       paranoia_seek(p,cursor=first_sector,SEEK_SET);      
 
diff -Naur cdparanoia-III-alpha9.8.orig/Makefile.in cdparanoia-III-alpha9.8/Makefile.in
--- cdparanoia-III-alpha9.8.orig/Makefile.in	2001-03-27 14:46:58.000000000 -0800
+++ cdparanoia-III-alpha9.8/Makefile.in	2006-07-19 15:08:29.000000000 -0700
@@ -64,28 +64,28 @@
 	cd paranoia && $(MAKE) slib
 
 install:
-	$(INSTALL) -d -m 0755 $(BINDIR)
-	$(INSTALL) -m 0755 $(srcdir)/cdparanoia $(BINDIR)
-	$(INSTALL) -d -m 0755 $(MANDIR)
-	$(INSTALL) -d -m 0755 $(MANDIR)/man1
-	$(INSTALL) -m 0644 $(srcdir)/cdparanoia.1 $(MANDIR)/man1
-	$(INSTALL) -d -m 0755 $(INCLUDEDIR)
-	$(INSTALL) -m 0644 $(srcdir)/paranoia/cdda_paranoia.h $(INCLUDEDIR)
-	$(INSTALL) -d -m 0755 $(LIBDIR)
-	$(INSTALL) -m 0644 $(srcdir)/paranoia/libcdda_paranoia.so.0.$(VERSION) $(LIBDIR)
-	$(INSTALL) -m 0644 $(srcdir)/paranoia/libcdda_paranoia.a $(LIBDIR)
-	$(INSTALL) -m 0644 $(srcdir)/interface/cdda_interface.h $(INCLUDEDIR)
-	$(INSTALL) -m 0644 $(srcdir)/interface/libcdda_interface.so.0.$(VERSION) $(LIBDIR)
-	$(INSTALL) -m 0644 $(srcdir)/interface/libcdda_interface.a $(LIBDIR)
-	$(INSTALL) -m 0644 $(srcdir)/utils.h $(INCLUDEDIR)
+	$(INSTALL) -d -m 0755 $(DESTDIR)$(BINDIR)
+	$(INSTALL) -m 0755 $(srcdir)/cdparanoia $(DESTDIR)$(BINDIR)
+	$(INSTALL) -d -m 0755 $(DESTDIR)$(MANDIR)
+	$(INSTALL) -d -m 0755 $(DESTDIR)$(MANDIR)/man1
+	$(INSTALL) -m 0644 $(srcdir)/cdparanoia.1 $(DESTDIR)$(MANDIR)/man1
+	$(INSTALL) -d -m 0755 $(DESTDIR)$(INCLUDEDIR)
+	$(INSTALL) -m 0644 $(srcdir)/paranoia/cdda_paranoia.h $(DESTDIR)$(INCLUDEDIR)
+	$(INSTALL) -d -m 0755 $(DESTDIR)$(LIBDIR)
+	$(INSTALL) -m 0644 $(srcdir)/paranoia/libcdda_paranoia.so.0.$(VERSION) $(DESTDIR)$(LIBDIR)
+	$(INSTALL) -m 0644 $(srcdir)/paranoia/libcdda_paranoia.a $(DESTDIR)$(LIBDIR)
+	$(INSTALL) -m 0644 $(srcdir)/interface/cdda_interface.h $(DESTDIR)$(INCLUDEDIR)
+	$(INSTALL) -m 0644 $(srcdir)/interface/libcdda_interface.so.0.$(VERSION) $(DESTDIR)$(LIBDIR)
+	$(INSTALL) -m 0644 $(srcdir)/interface/libcdda_interface.a $(DESTDIR)$(LIBDIR)
+	$(INSTALL) -m 0644 $(srcdir)/utils.h $(DESTDIR)$(INCLUDEDIR)
 	ln -fs libcdda_interface.so.0.$(VERSION) \
-		$(LIBDIR)/libcdda_interface.so.0
+		$(DESTDIR)$(LIBDIR)/libcdda_interface.so.0
 	ln -fs libcdda_interface.so.0.$(VERSION) \
-		$(LIBDIR)/libcdda_interface.so
+		$(DESTDIR)$(LIBDIR)/libcdda_interface.so
 	ln -fs libcdda_paranoia.so.0.$(VERSION) \
-		$(LIBDIR)/libcdda_paranoia.so.0
+		$(DESTDIR)$(LIBDIR)/libcdda_paranoia.so.0
 	ln -fs libcdda_paranoia.so.0.$(VERSION) \
-		$(LIBDIR)/libcdda_paranoia.so
+		$(DESTDIR)$(LIBDIR)/libcdda_paranoia.so
 
 cdparanoia:	$(OFILES) $(LIBDEP)
 		$(LD) $(CFLAGS) $(LDFLAGS) $(OFILES) \
diff -Naur cdparanoia-III-alpha9.8.orig/paranoia/cdda_paranoia.h cdparanoia-III-alpha9.8/paranoia/cdda_paranoia.h
--- cdparanoia-III-alpha9.8.orig/paranoia/cdda_paranoia.h	2001-03-23 17:15:47.000000000 -0800
+++ cdparanoia-III-alpha9.8/paranoia/cdda_paranoia.h	2006-07-19 15:05:21.000000000 -0700
@@ -37,6 +37,8 @@
 typedef void cdrom_paranoia;
 #endif
 
+#include <cdda_interface.h>
+
 extern cdrom_paranoia *paranoia_init(cdrom_drive *d);
 extern void paranoia_modeset(cdrom_paranoia *p,int mode);
 extern long paranoia_seek(cdrom_paranoia *p,long seek,int mode);
diff -Naur cdparanoia-III-alpha9.8.orig/paranoia/gap.c cdparanoia-III-alpha9.8/paranoia/gap.c
--- cdparanoia-III-alpha9.8.orig/paranoia/gap.c	2000-04-19 15:41:04.000000000 -0700
+++ cdparanoia-III-alpha9.8/paranoia/gap.c	2006-07-20 12:07:24.000000000 -0700
@@ -6,6 +6,7 @@
  *
  ***/
 
+#include <string.h>
 #include "p_block.h"
 #include "cdda_paranoia.h"
 #include "gap.h"
diff -Naur cdparanoia-III-alpha9.8.orig/paranoia/Makefile.in cdparanoia-III-alpha9.8/paranoia/Makefile.in
--- cdparanoia-III-alpha9.8.orig/paranoia/Makefile.in	1999-12-13 20:28:04.000000000 -0800
+++ cdparanoia-III-alpha9.8/paranoia/Makefile.in	2006-07-19 15:22:27.000000000 -0700
@@ -11,6 +11,7 @@
 FLAGS=@TYPESIZES@ @CFLAGS@
 OPT=@OPT@ $(FLAGS)
 DEBUG=@DEBUG@ $(FLAGS)
+LIBFLAGS=-fPIC
 CC=@CC@
 LD=@CC@
 LDFLAGS=@LDFLAGS@ $(FLAGS)
@@ -34,7 +35,7 @@
 
 slib:	
 	$(MAKE) lessmessy
-	$(MAKE) libcdda_paranoia.so CFLAGS="$(OPT) -fpic" 
+	$(MAKE) libcdda_paranoia.so CFLAGS="$(OPT)" 
 
 #test:	$(TFILES)
 #
@@ -44,12 +45,12 @@
 	$(RANLIB) libcdda_paranoia.a
 
 libcdda_paranoia.so: 	$(OFILES)	
-	$(CC) -fpic -shared -o libcdda_paranoia.so.0.$(VERSION) -Wl,-soname -Wl,libcdda_paranoia.so.0 $(OFILES)
+	$(CC) $(LDFLAGS) $(LIBFLAGS) -shared -o libcdda_paranoia.so.0.$(VERSION) -Wl,-soname -Wl,libcdda_paranoia.so.0 $(OFILES) -L ../interface -lcdda_interface
 	[ -e libcdda_paranoia.so.0 ] || ln -s libcdda_paranoia.so.0.$(VERSION) libcdda_paranoia.so.0
 	[ -e libcdda_paranoia.so ] || ln -s libcdda_paranoia.so.0.$(VERSION) libcdda_paranoia.so
 
 .c.o:
-	$(CC) $(CFLAGS) -c $<
+	$(CC) $(CFLAGS) $(LIBFLAGS) -c $<
 
 .c.t:
 	$(CC) -g -DTEST $(DEBUG) -o $@ $< $(LIBS)
diff -Naur cdparanoia-III-alpha9.8.orig/report.c cdparanoia-III-alpha9.8/report.c
--- cdparanoia-III-alpha9.8.orig/report.c	1999-08-15 14:52:30.000000000 -0700
+++ cdparanoia-III-alpha9.8/report.c	2006-07-19 15:16:06.000000000 -0700
@@ -2,7 +2,7 @@
 #include "interface/cdda_interface.h"
 
 int quiet=0;
-int verbose=CDDA_MESSAGE_FORGETIT;
+int verbose=CDDA_MESSAGE_PRINTIT;
 
 void report(char *s){
   if(!quiet){
