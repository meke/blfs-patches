Submitted By:            Randy McMurchy <randy_at_linuxfromscratch_dot_org>
Date:                    2005-10-02
Initial Package Version: 1.0.3
Upstream Status:         Unknown
Origin:                  GCC-4 fixes from
       http://sourceforge.net/tracker/index.php?func=detail&aid=1202325&group_id=10501&atid=310501
                         Using --with-exporter doesn't work unless you include the
                         oledecod directory from the 1.0.2 source tree
Description:             Fixes using --with-exporter and a GCC-4.0.x build problem


diff -Naur wv-1.0.3-orig/oledecod/COPYING wv-1.0.3/oledecod/COPYING
--- wv-1.0.3-orig/oledecod/COPYING	1970-01-01 00:00:00.000000000 +0000
+++ wv-1.0.3/oledecod/COPYING	2005-10-02 23:35:02.000000000 +0000
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Naur wv-1.0.3-orig/oledecod/GNUmakefile.am wv-1.0.3/oledecod/GNUmakefile.am
--- wv-1.0.3-orig/oledecod/GNUmakefile.am	1970-01-01 00:00:00.000000000 +0000
+++ wv-1.0.3/oledecod/GNUmakefile.am	2005-10-02 23:35:02.000000000 +0000
@@ -0,0 +1,19 @@
+if BUILD_GLIB
+INCGLIB = -I$(top_srcdir)/glib-wv
+else
+INCGLIB = 
+endif
+
+INCLUDES = -I. -I$(top_builddir) -I$(srcdir) -I$(top_srcdir) -I$(top_srcdir)/libole2 -I$(top_srcdir)/oledecod $(INCGLIB)
+
+CPPFLAGS = @CPPFLAGS@ @GLIB_CFLAGS@ @ICONV_CFLAGS@ @ZLIB_CFLAGS@
+
+noinst_LTLIBRARIES = liboledecod.la
+
+liboledecod_la_SOURCES = oledecod.c
+
+OTHERHEADERS = \
+	oledecod.h \
+	support.h
+
+EXTRA_DIST = $(OTHERHEADERS)
diff -Naur wv-1.0.3-orig/oledecod/GNUmakefile.in wv-1.0.3/oledecod/GNUmakefile.in
--- wv-1.0.3-orig/oledecod/GNUmakefile.in	1970-01-01 00:00:00.000000000 +0000
+++ wv-1.0.3/oledecod/GNUmakefile.in	2005-10-02 23:35:02.000000000 +0000
@@ -0,0 +1,468 @@
+# GNUmakefile.in generated by automake 1.8.4 from GNUmakefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+SOURCES = $(liboledecod_la_SOURCES)
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_triplet = @host@
+subdir = oledecod
+DIST_COMMON = README $(srcdir)/GNUmakefile.am $(srcdir)/GNUmakefile.in \
+	COPYING
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+liboledecod_la_LIBADD =
+am_liboledecod_la_OBJECTS = oledecod.lo
+liboledecod_la_OBJECTS = $(am_liboledecod_la_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/oledecod.Plo
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(liboledecod_la_SOURCES)
+DIST_SOURCES = $(liboledecod_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+ANSI_CFLAGS = @ANSI_CFLAGS@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BUILD_EXPAT_FALSE = @BUILD_EXPAT_FALSE@
+BUILD_EXPAT_TRUE = @BUILD_EXPAT_TRUE@
+BUILD_EXPORTER_FALSE = @BUILD_EXPORTER_FALSE@
+BUILD_EXPORTER_TRUE = @BUILD_EXPORTER_TRUE@
+BUILD_GLIB_FALSE = @BUILD_GLIB_FALSE@
+BUILD_GLIB_TRUE = @BUILD_GLIB_TRUE@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@ @GLIB_CFLAGS@ @ICONV_CFLAGS@ @ZLIB_CFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+EXPORTER = @EXPORTER@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_CONFIG = @GLIB_CONFIG@
+GLIB_LIBS = @GLIB_LIBS@
+HAVE_GLIB = @HAVE_GLIB@
+HAVE_LIBXML2 = @HAVE_LIBXML2@
+ICONV_CFLAGS = @ICONV_CFLAGS@
+ICONV_LIBS = @ICONV_LIBS@
+INCLUDED_EXPAT = @INCLUDED_EXPAT@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIBWMF_CONFIG = @LIBWMF_CONFIG@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+PNG_CFLAGS = @PNG_CFLAGS@
+PNG_LIBS = @PNG_LIBS@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+WMF_CFLAGS = @WMF_CFLAGS@
+WMF_LIBS = @WMF_LIBS@
+WV_BINARY_AGE = @WV_BINARY_AGE@
+WV_INTERFACE_AGE = @WV_INTERFACE_AGE@
+WV_MAJOR_VERSION = @WV_MAJOR_VERSION@
+WV_MICRO_VERSION = @WV_MICRO_VERSION@
+WV_MINOR_VERSION = @WV_MINOR_VERSION@
+WV_VERSION = @WV_VERSION@
+XML2_CONFIG = @XML2_CONFIG@
+XML_CFLAGS = @XML_CFLAGS@
+XML_LIBS = @XML_LIBS@
+ZLIB_CFLAGS = @ZLIB_CFLAGS@
+ZLIB_LIBS = @ZLIB_LIBS@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+@BUILD_GLIB_FALSE@INCGLIB = 
+@BUILD_GLIB_TRUE@INCGLIB = -I$(top_srcdir)/glib-wv
+INCLUDES = -I. -I$(top_builddir) -I$(srcdir) -I$(top_srcdir) -I$(top_srcdir)/libole2 -I$(top_srcdir)/oledecod $(INCGLIB)
+noinst_LTLIBRARIES = liboledecod.la
+liboledecod_la_SOURCES = oledecod.c
+OTHERHEADERS = \
+	oledecod.h \
+	support.h
+
+EXTRA_DIST = $(OTHERHEADERS)
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/GNUmakefile.in:  $(srcdir)/GNUmakefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  oledecod/GNUmakefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  oledecod/GNUmakefile
+.PRECIOUS: GNUmakefile
+GNUmakefile: $(srcdir)/GNUmakefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" = "$$p" && dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+liboledecod.la: $(liboledecod_la_OBJECTS) $(liboledecod_la_DEPENDENCIES) 
+	$(LINK)  $(liboledecod_la_LDFLAGS) $(liboledecod_la_OBJECTS) $(liboledecod_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/oledecod.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Plo' tmpdepfile='$(DEPDIR)/$*.TPlo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -z "$$unique" && unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: GNUmakefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f GNUmakefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f GNUmakefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am \
+	uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur wv-1.0.3-orig/oledecod/README wv-1.0.3/oledecod/README
--- wv-1.0.3-orig/oledecod/README	1970-01-01 00:00:00.000000000 +0000
+++ wv-1.0.3/oledecod/README	2005-10-02 23:35:02.000000000 +0000
@@ -0,0 +1,9 @@
+0.0.3:
++ Add one parameter to OLEdecod; max_level, which is the maximum level
+  stream we will extract into files.
++ Changed name from main.c to demo.c
++ Added a simple Makefile
++ Added this README file.
+
+--
+Arturo Tena <arturo@directmail.org>
diff -Naur wv-1.0.3-orig/oledecod/oledecod.c wv-1.0.3/oledecod/oledecod.c
--- wv-1.0.3-orig/oledecod/oledecod.c	1970-01-01 00:00:00.000000000 +0000
+++ wv-1.0.3/oledecod/oledecod.c	2005-10-02 23:35:02.000000000 +0000
@@ -0,0 +1,564 @@
+/*
+   OLEdecode - Decode Microsoft OLE files into its components.
+   Copyright (C) 1998  Andrew Scriven
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*
+   Released under GPL, written by 
+   Andrew Scriven <andy.scriven@research.natpower.co.uk>
+
+   Copyright (C) 1998
+   Andrew Scriven
+ */
+/*
+   -----------------------------------------------------------------------
+   Andrew Scriven
+   Research and Engineering
+   Electron Building, Windmill Hill, Whitehill Way, Swindon, SN5 6PB, UK
+   Phone (44) 1793 896206, Fax (44) 1793 896251
+   -----------------------------------------------------------------------
+ */
+/*
+   Extremely modified by
+   Arturo Tena <arturo@directmail.org> <filters@centauri.lci.ulsa.mx>
+ */
+/*
+   The interface to OLEdecode now has
+   int OLEdecode (FILE *OLEfile, pps_entry ** stream_list, U32 * root,
+		  U16 max_level);
+   See the oledecod.h to see a description of the inputs and output
+ */
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+/* #include <sys/types.h> */
+#include <assert.h>
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "wv.h"
+
+#include "oledecod.h"
+
+
+#define ENTRYCHUNK 20		/* number of entries in root_list and sbd_list
+				   will be added each time. must be at least 1 */
+
+	/* verbose pps tree */
+static void verbosePPSTree (U32 root_pps, int level);
+	/* reorder pps tree, from tree structure to a linear one,
+	   and write the level numbers */
+static void reorder_pps_tree (pps_entry * root_pps, U16 level);
+	/* free memory used (except the pps tree) */
+static void ends (void);
+
+
+static U8 *Block;
+static U8 *BDepot, *SDepot, *Root;
+static pps_entry *pps_list = NULL;
+static U32 num_of_pps = 0;
+static FILE *sbfile = NULL;
+static char sbfilename[L_tmpnam];
+static U32 *sbd_list;
+static U32 *root_list;
+
+int
+OLEdecode (FILE *input, pps_entry ** stream_list, U32 * root, U16 max_level)
+{
+  int c;
+  U32 num_bbd_blocks;
+  U32 i, len;
+  U8 *s, *p, *t;
+  long FilePos;
+  /* FilePos is long, not U32, because second argument of fseek is long */
+
+  /* initialize static variables */
+  Block = BDepot = SDepot = Root = NULL;
+  pps_list = NULL;
+  num_of_pps = 0;
+  sbfilename[0] = 0;
+  root_list = sbd_list = NULL;
+
+  /* open input file */
+  test (input != NULL, 4, ends ()); /* cannot be opened */
+
+  /* fast check type of file */
+  verbose ("fast testing type of file");
+  test ((c = getc (input)) != EOF, 5, ends ());
+  test (ungetc (c, input) != EOF, 5, ends ());
+  test ( (c < 32 || c > 126) , 8, ends ());  /* We have a legible character, not good */
+  test (c != 0xdb, 2, ends ());  /* probably non-ole Word 2 file */
+  test (c == 0xd0, 9, ends ());
+
+  /* read header block */
+  verbose ("read header block");
+  Block = (U8 *) malloc (0x0200);
+  test (Block != NULL, 10, ends ());
+  fread (Block, 0x0200, 1, input);
+  test (!ferror (input), 5, ends ());
+
+  /* really check type of file */
+  rewind (input);
+  verbose ("testing type of file");
+  test (fil_sreadU32 (Block) != 0xd0cf11e0UL, 9, ends ());
+  test (fil_sreadU32 (Block + 0x04) != 0xa1b11ae1UL, 9, ends ());
+
+
+  /* read big block depot */
+  verbose ("read big block depot (bbd)");
+  num_bbd_blocks = fil_sreadU32 (Block + 0x2c);
+  verboseU32 (num_bbd_blocks);
+  BDepot = malloc (0x0200 * num_bbd_blocks);
+  test (BDepot != NULL, 10, ends ());
+  s = BDepot;
+  for (i = 0; i < num_bbd_blocks; i++)
+    {
+      /* note: next line may be needed to be cast to long in right side */
+      FilePos = 0x0200 * (1 + fil_sreadU32 (Block + 0x4c + (i * 4)));
+      assert (FilePos >= 0);
+      test (!fseek (input, FilePos, SEEK_SET), 5, ends ());
+      fread (s, 0x0200, 1, input);
+      test (!ferror (input), 5, ends ());
+      s += 0x0200;
+    }
+  verboseU8Array (BDepot, num_bbd_blocks, 0x0200);
+
+
+  /* extract the sbd block list */
+  verbose ("extract small block depot (sbd) block list");
+  sbd_list = malloc (ENTRYCHUNK * 4);
+  test (sbd_list != NULL, 10, ends ());
+  sbd_list[0] = fil_sreadU32 (Block + 0x3c);
+  /* -2 signed long int == 0xfffffffe unsinged long int */
+  for (len = 1; sbd_list[len - 1] != 0xfffffffeUL; len++)
+    {
+      test (len != 0, 5, ends ());	/* means file is too big */
+      /* if memory allocated in sbd_list is all used, allocate more memory */
+      if (!(len % ENTRYCHUNK))
+	{
+	  U32 *newspace;
+	  newspace = realloc (sbd_list,
+			      (1 + len / ENTRYCHUNK) * ENTRYCHUNK * 4);
+	  test (newspace != NULL, 10, ends ());
+	  sbd_list = newspace;
+	}
+	  if ( (sbd_list[len - 1] * 4) >= (0x0200 * num_bbd_blocks))
+		return(5);
+      sbd_list[len] = fil_sreadU32 (BDepot + (sbd_list[len - 1] * 4));
+      test (sbd_list[len] != 0xfffffffdUL && sbd_list[len] != 0xffffffffUL,
+	    5, ends ());
+    }
+  len--;
+  verboseU32Array (sbd_list, len);
+  /* read in small block depot, if there's any small block */
+  if (len == 0)
+    {
+      SDepot = NULL;
+      verbose ("not read small block depot (sbd): there's no small blocks");
+    }
+  else
+    {
+      verbose ("read small block depot (sbd)");
+      SDepot = malloc (0x0200 * len);
+      test (SDepot != NULL, 10, ends ());
+      s = SDepot;
+      for (i = 0; i < len; i++)
+	{
+	  FilePos = 0x0200 * (1 + sbd_list[i]);
+	  assert (FilePos >= 0);
+	  test (!fseek (input, FilePos, SEEK_SET), 5, ends ());
+	  fread (s, 0x0200, 1, input);
+	  test (!ferror (input), 5, ends ());
+	  s += 0x200;
+	}
+      verboseU8Array (SDepot, len, 0x0200);
+    }
+
+
+  /* extract the root block list */
+  verbose ("extract root block depot (root) block list");
+  root_list = malloc (ENTRYCHUNK * 4);
+  test (root_list != NULL, 10, ends ());
+  root_list[0] = fil_sreadU32 (Block + 0x30);
+  for (len = 1; root_list[len - 1] != 0xfffffffeUL; len++)
+    {
+      test (len != 0, 5, ends ());	/* means file is too long */
+      /* if memory allocated in root_list is all used, allocate more memory */
+      if (!(len % ENTRYCHUNK))
+	{
+	  U32 *newspace;
+	  newspace = realloc (root_list,
+			      (1 + len / ENTRYCHUNK) * ENTRYCHUNK * 4);
+	  test (newspace != NULL, 10, ends ());
+	  root_list = newspace;
+	}
+      root_list[len] = fil_sreadU32 (BDepot + (root_list[len - 1] * 4));
+      test (root_list[len] != 0xfffffffdUL && root_list[len] != 0xffffffffUL,
+	    5, ends ());
+    }
+  len--;
+  verboseU32Array (root_list, len);
+  /* read in root block depot */
+  verbose ("read in root block depot (Root)");
+  Root = malloc (0x0200 * len);
+  test (Root != NULL, 10, ends ());
+  s = Root;
+  for (i = 0; i < len; i++)
+    {
+      FilePos = 0x0200 * (root_list[i] + 1);
+      assert (FilePos >= 0);
+      test (!fseek (input, FilePos, SEEK_SET), 5, ends ());
+      fread (s, 0x0200, 1, input);
+      test (!ferror (input), 5, ends ());
+      s += 0x200;
+    }
+  verboseU8Array (Root, len, 0x0200);
+
+
+  /* assign space for pps list */
+  verbose ("read pps list");
+  num_of_pps = len * 4;		/* each sbd block have 4 pps */
+  *stream_list = pps_list = malloc (num_of_pps * sizeof (pps_entry));
+  test (pps_list != NULL, 10, ends ());
+  /* read pss entry details and look out for "Root Entry" */
+  verbose ("read pps entry details");
+  for (i = 0; i < num_of_pps; i++)
+    {
+      U16 size_of_name;
+
+      s = Root + (i * 0x80);
+
+      /* read the number */
+      pps_list[i].ppsnumber = i;
+
+      /* read the name */
+      size_of_name = fil_sreadU16 (s + 0x40);
+      pps_list[i].name[0] = 0;
+      if (size_of_name == 0)
+	continue;
+      for (p = (unsigned char *) pps_list[i].name, t = s;
+	   t < s + size_of_name; t++)
+	*p++ = *t++;
+      /* makes visible the non printable first character */
+      if (!isprint (pps_list[i].name[0]) && pps_list[i].name[0])
+	pps_list[i].name[0] += 'a';
+
+      /* read the type */
+      pps_list[i].type = fil_sreadU8 (s + 0x42);
+      if (pps_list[i].type == 5)
+	{
+	  assert (i == 0);
+	  strcpy(pps_list[i].name,"Root Entry");
+	  *root = i;		/* this pps is the root */
+	}
+
+      /* read the others fields */
+      pps_list[i].previous = fil_sreadU32 (s + 0x44);
+      pps_list[i].next = fil_sreadU32 (s + 0x48);
+      pps_list[i].dir = fil_sreadU32 (s + 0x4c);
+      pps_list[i].start = fil_sreadU32 (s + 0x74);
+      pps_list[i].size = fil_sreadU32 (s + 0x78);
+      pps_list[i].seconds1 = fil_sreadU32 (s + 0x64);
+      pps_list[i].seconds2 = fil_sreadU32 (s + 0x6c);
+      pps_list[i].days1 = fil_sreadU32 (s + 0x68);
+      pps_list[i].days2 = fil_sreadU32 (s + 0x70);
+    }
+
+  /* NEXT IS VERBOSE verbose */
+#ifdef VERBOSE
+  {
+    U32 i;
+    printf ("before reorder pps tree\n");
+    printf ("pps    type    prev     next      dir start   level size     name\n");
+    for (i = 0; i < num_of_pps; i++)
+      {
+	if (!pps_list[i].name[0])
+	  continue;
+	printf ("%08lx ", pps_list[i].ppsnumber);
+	printf ("%d ", pps_list[i].type);
+	printf ("%08lx ", pps_list[i].previous);
+	printf ("%08lx ", pps_list[i].next);
+	printf ("%08lx ", pps_list[i].dir);
+	printf ("%08lx ", pps_list[i].start);
+	printf ("%04x ", pps_list[i].level);
+	printf ("%08lx ", pps_list[i].size);
+	printf ("%s\n", pps_list[i].name);
+      }
+  }
+#endif
+
+  /* go through the tree made with pps entries, and reorder it so only the
+     next link is used (move the previous-link-children to the last visited
+     next-link-children) */
+  reorder_pps_tree (&pps_list[*root], 0);
+#ifdef VERBOSE
+  /* NEXT IS VERBOSE verbose */
+  {
+    U32 i;
+    printf ("after reorder pps tree\n");
+    printf ("pps    type    prev     next      dir start   level size     name\n");
+    for (i = 0; i < num_of_pps; i++)
+      {
+	if (!pps_list[i].name[0])
+	  continue;
+	printf ("%08lx ", pps_list[i].ppsnumber);
+	printf ("%d ", pps_list[i].type);
+	printf ("%08lx ", pps_list[i].previous);
+	printf ("%08lx ", pps_list[i].next);
+	printf ("%08lx ", pps_list[i].dir);
+	printf ("%08lx ", pps_list[i].start);
+	printf ("%04x ", pps_list[i].level);
+	printf ("%08lx ", pps_list[i].size);
+	printf ("%s\n", pps_list[i].name);
+      }
+  }
+  /* NEXT IS VERBOSE verbose */
+  verbosePPSTree (*root, 0);
+#endif
+
+
+  /* generates pps real files */
+  /* NOTE: by this moment, the pps tree,
+     wich is made with pps_list entries, is reordered */
+  verbose ("create pps files");
+  {
+    U8 *Depot;
+    FILE *OLEfile, *infile;
+    U16 BlockSize, Offset;
+    size_t bytes_to_read;
+    U32 pps_size, pps_start;
+#define THEMIN(a,b) ((a)<(b) ? (a) : (b))
+
+    for (i = 0; i < num_of_pps; i++)
+      {
+	/* storage pps and non-valid-pps does not need files */
+	if (pps_list[i].type == 1 || !pps_list[i].name[0])
+	  {
+	    pps_list[i].filename[0] = 0;
+	    continue;
+	  }
+	/* pps that have level > max_level will not be extracterd */
+	if (max_level != 0 && pps_list[i].level > max_level)
+	  {
+	    pps_list[i].filename[0] = 0;
+	    continue;
+	  }
+
+	pps_start = pps_list[i].start;
+	pps_size = pps_list[i].size;
+
+	pps_list[i].filename[0] = 0;
+	/* create the new file */
+	if (pps_list[i].type == 5)
+	  /* root entry, sbfile must be generated */
+	  {
+	    assert (i == *root);
+	    assert (i == 0);
+	    wvTempName (sbfilename);
+	    test (sbfilename[0], 7, ends ());
+	    sbfile = OLEfile = fopen (sbfilename, "wb+");
+	    test (OLEfile != NULL, 7, ends ());
+	    verboseS (sbfilename);
+	  }
+	else
+	  /* other entry, save in a file */
+	  {
+	    wvTempName (pps_list[i].filename);
+	    test (pps_list[i].filename[0], 7, ends ());
+	    verbose (pps_list[i].name);
+	    OLEfile = fopen (pps_list[i].filename, "wb");
+	    test (OLEfile != NULL, 7, ends ());
+	    verbose (pps_list[i].filename);
+	  }
+
+	if (pps_size >= 0x1000 /*is in bbd */  ||
+	    OLEfile == sbfile  /*is root */ )
+	  {
+	    /* read from big block depot */
+	    Offset = 1;
+	    BlockSize = 0x0200;
+	    infile = input;
+	    Depot = BDepot;
+	  }
+	else
+	  {
+	    /* read from small block file */
+	    Offset = 0;
+	    BlockSize = 0x40;
+	    infile = sbfile;
+	    Depot = SDepot;
+	  }
+
+	/* -2 signed long int == 0xfffffffe unsinged long int */
+	while (pps_start != 0xfffffffeUL)
+	  {
+#ifdef VERBOSE
+	    printf ("reading pps %08lx block %08lx from %s\n",
+		    pps_list[i].ppsnumber, pps_start,
+		 Depot == BDepot ? "big block depot" : "small block depot");
+#endif
+	    FilePos = (pps_start + Offset) * BlockSize;
+	    assert (FilePos >= 0);
+	    bytes_to_read = THEMIN (BlockSize, pps_size);
+	    fseek (infile, FilePos, SEEK_SET);
+	    fread (Block, bytes_to_read, 1, infile);
+	    test (!ferror (infile), 5, ends ());
+	    fwrite (Block, bytes_to_read, 1, OLEfile);
+	    test (!ferror (infile), 5, ends ());
+	    assert (Depot != NULL);	/* may be sbd no contains blocks */
+	    pps_start = fil_sreadU32 (Depot + (pps_start * 4));
+	    pps_size -= THEMIN (BlockSize, pps_size);
+	    if (pps_size == 0)
+	      pps_start = 0xfffffffeUL;
+
+	  }
+	if (OLEfile == sbfile)
+	  /* if small block file generated */
+	  rewind (OLEfile);	/* rewind because we will reader later */
+	else if (!fclose (OLEfile))	/* close the pps file */
+	  /* don't know what to do here */
+	  ;
+      }
+    if (sbfile != NULL)
+      {
+	fclose (sbfile);
+	if (!remove (sbfilename))
+	  /* don't know what to do here */
+	  ;
+	sbfile = NULL;
+      }
+  }
+  ends ();
+  return 0;
+}
+
+
+/* reorder pps tree and write levels */
+/* not sure if it is safe declare last_next_link_visited inside reorder_pps_tree */
+static U32 *last_next_link_visited;
+void
+reorder_pps_tree (pps_entry * node, U16 level)
+{
+	static int depth;
+	depth++;
+  /* NOTE: in next, previous and dir link,
+     0xffffffff means point to nowhere (NULL) */
+
+  if (depth == 50)
+  	{
+  	wvError(("this ole tree appears far too deep\n"));
+	depth--;
+  	return;
+	}
+
+  node->level = level;
+
+  /* reorder subtrees, if there's any */
+  if (node->dir != 0xffffffffUL)
+  	{
+    reorder_pps_tree (&pps_list[node->dir], (U16) (level+1) );
+	}
+
+  /* reorder next-link subtree, saving the most next link visited */
+  if (node->next != 0xffffffffUL)
+    reorder_pps_tree (&pps_list[node->next], level);
+  else
+    last_next_link_visited = &node->next;
+
+  /* move the prev child to the next link and reorder it, if there's any */
+  if (node->previous != 0xffffffffUL)
+    {
+      *last_next_link_visited = node->previous;
+      node->previous = 0xffffffffUL;
+      reorder_pps_tree (&pps_list[*last_next_link_visited], level);
+    }
+	depth--;
+}
+
+
+/* verbose pps tree */
+void
+verbosePPSTree (U32 start_entry, int level)
+{
+  U32 entry;
+  int i;
+
+  for (entry = start_entry; entry != 0xffffffffUL; entry = pps_list[entry].next)
+    {
+      if (pps_list[entry].type == 2)
+	{
+	  for (i = 0; i < level * 3; i++)
+	    printf (" ");
+	  printf ("FILE %02lx %5ld %s\n", pps_list[entry].ppsnumber,
+		  pps_list[entry].size, pps_list[entry].name);
+	}
+      else
+	{
+	  for (i = 0; i < level * 3; i++)
+	    printf (" ");
+	  printf ("DIR  %02lx %s\n", pps_list[entry].ppsnumber,
+		  pps_list[entry].name);
+	  verbosePPSTree (pps_list[entry].dir, level + 1);
+	}
+    }
+}
+
+
+#define freeNoNULL(x) { if ((x) != NULL) free (x); (x) = NULL; }
+
+void
+closeOLEtreefiles (pps_entry * tree, U32 root)
+{
+  if (tree[root].previous != 0xffffffffUL)
+    closeOLEtreefiles (tree, tree[root].previous);
+  if (tree[root].next != 0xffffffffUL)
+    closeOLEtreefiles (tree, tree[root].next);
+  if ((tree[root].type != 2) && (tree[root].dir != 0xffffffffUL))
+    closeOLEtreefiles (tree, tree[root].dir);
+  else if (!remove (tree[root].filename))
+    /* I don't know what to do here, may be print a message? */
+    ;
+}
+
+void
+freeOLEtree (pps_entry * tree)
+{
+   if (tree) closeOLEtreefiles (tree, 0);
+  freeNoNULL (tree);
+}
+
+
+/* free memory used (except the pps tree) */
+void
+ends (void)
+{
+  freeNoNULL (Block);
+  freeNoNULL (BDepot);
+  freeNoNULL (SDepot);
+  freeNoNULL (Root);
+  freeNoNULL (sbd_list);
+  freeNoNULL (root_list);
+  if (sbfile != NULL)
+    {
+      fclose (sbfile);
+      if (!remove (sbfilename))
+	/* I don't know what to do here, may be print a message? */
+	;
+    }
+}
diff -Naur wv-1.0.3-orig/oledecod/oledecod.h wv-1.0.3/oledecod/oledecod.h
--- wv-1.0.3-orig/oledecod/oledecod.h	1970-01-01 00:00:00.000000000 +0000
+++ wv-1.0.3/oledecod/oledecod.h	2005-10-02 23:35:02.000000000 +0000
@@ -0,0 +1,96 @@
+/*
+   OLEdecode - Decode Microsoft OLE files into its components.
+   Copyright (C) 1998  Andrew Scriven
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*
+   Released under GPL, written by 
+   Andrew Scriven <andy.scriven@research.natpower.co.uk>
+
+   Copyright (C) 1998
+   Andrew Scriven
+ */
+/*
+   -----------------------------------------------------------------------
+   Andrew Scriven
+   Research and Engineering
+   Electron Building, Windmill Hill, Whitehill Way, Swindon, SN5 6PB, UK
+   Phone (44) 1793 896206, Fax (44) 1793 896251
+   -----------------------------------------------------------------------
+ */
+/*
+   Extremely modified by
+   Arturo Tena <arturo@directmail.org> <filters@centauri.lci.ulsa.mx>
+ */
+#ifndef OLEDECOD_H
+#define OLEDECOD_H
+
+
+#include <stdio.h>
+
+#include "support.h"
+
+
+struct pps_block
+  {
+    char name[0x20];
+    char filename[L_tmpnam];	/* valid only if type == 2 */
+    U8 type;			/* 5 == root, 1 == dir, 2 == file */
+    U32 size;			/* the size of the file, valid only if type == 2 */
+    U32 next;			/* next entry in this level, in this directory */
+    U32 dir;			/* valid only if type != 2 */
+    U16 level;			/* level in the ole tree */
+    U32 seconds1;
+    U32 seconds2;
+    U32 days1;
+    U32 days2;
+
+    /* private fields, used only inside OLEdecoded and useless after */
+    U32 previous;		/* previous pps, valid before reordering */
+    U32 ppsnumber;		/* pps number */
+    U32 start;			/* start block */
+  };
+typedef struct pps_block pps_entry;
+
+
+/*
+   Input: char *Olefilename        = File to be decoded (ie. .xsl, .doc, .ppt).
+   .      pps_entry ** stream_list = The stream tree.
+   .      U32 * root               = The number of root dir in stream_list.
+   .      U16 max_level            = The maximum level on stream tree in which
+   .                                 streams will be actually extracted
+   .                                 to a file. 0 (zero) means extract all.
+   Output: 0 = Sucess.
+   .       4 = Couldn't open OLEfilename file (can use perror).
+   .       8 = OLEfilename file seems to contain plain text, not OLE file.
+   .       9 = OLEfilename file has a faulty OLEfile format.
+   .       5 = Error reading from file, means OLEfilename file has a faulty
+   .           OLE file format.
+   .       6 = Error removing temporal files.
+   .       7 = Error creating temporal files.
+   .       10 = Error allocating memory, there's no more memory.
+ */
+int OLEdecode (FILE *OLEfile, pps_entry ** stream_list, U32 * root,
+		U16 max_level);
+
+
+/*
+   Free all the memory allocated in the tree.
+ */
+void freeOLEtree (pps_entry * tree);
+
+
+#endif /* OLEDECOD_H */
diff -Naur wv-1.0.3-orig/oledecod/support.h wv-1.0.3/oledecod/support.h
--- wv-1.0.3-orig/oledecod/support.h	1970-01-01 00:00:00.000000000 +0000
+++ wv-1.0.3/oledecod/support.h	2005-10-02 23:35:02.000000000 +0000
@@ -0,0 +1,106 @@
+/*
+   Support - Provides some big and little endian abstraction functions.
+   Copyright (C) 1998  Caolan McNamara
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+ */
+/*
+  Caolan McNamara <Caolan.McNamara@ul.ie>
+  Real Life: Caolan McNamara           *  Doing: MSc in HCI
+  Work: Caolan.McNamara@ul.ie          *  Phone: +353-61-202699
+  URL: http://www.csn.ul.ie/~caolan    *  Sig: an oblique strategy
+ */
+
+
+
+#define fil_sreadU8 sread_8ubit
+#define fil_sreadU16 sread_16ubit
+#define fil_sreadU32 sread_32ubit
+
+
+#define test(t,retval,func) \
+	{ \
+		if (!(t)) { \
+			func; \
+			return retval; \
+		} \
+	}
+
+
+#ifdef VERBOSE
+#define verbose(s) { printf (s); printf ("\n"); }
+#else
+#define verbose(s)
+#endif
+
+#ifdef VERBOSE
+#define verboseU32(expr) { printf (#expr " = 0x%08lx\n", expr); }
+#else
+#define verboseU32(expr)
+#endif
+
+#ifdef VERBOSE
+#define verboseS(expr) { printf (#expr " = %s\n", expr); }
+#else
+#define verboseS(expr)
+#endif
+
+#ifdef VERBOSE
+#define verboseU32Array(array,len) \
+	{ \
+		U32 temp; \
+		for (temp = 0; temp <= len; temp++) \
+			printf (#array "[%lu] = 0x%08lx\n", temp, array [temp]); \
+	}
+#else
+#define verboseU32Array(array,len)
+#endif
+
+#ifdef VERBOSE
+#ifdef SHOWCHAR
+#define verboseU8Array(arr,len,sblock) \
+        { \
+                U32 temp1, temp2; \
+                for (temp1 = 0; temp1 < len; temp1++) \
+                { \
+                printf ("\n***%08lx***\n", temp1); \
+                for (temp2 = 0; temp2 < sblock; temp2++) \
+		{ \
+	                printf ("%02x ", *(arr + (temp1 * 0x0200 + temp2))); \
+			if (!((temp2+1) % 0x10)) printf ("\n"); \
+		} \
+                } \
+        }
+#else /* show caracters */
+#define verboseU8Array(arr,len,sblock) \
+        { \
+                U32 temp1, temp2; \
+                for (temp1 = 0; temp1 < len; temp1++) \
+                { \
+                printf ("\n***%08lx***\n", temp1); \
+                for (temp2 = 0; temp2 < sblock; temp2++) \
+		{ \
+			if (isprint (*(arr + (temp1 * 0x0200 + temp2)))) \
+	                        printf ("%c ", *(arr + (temp1 * 0x0200 + temp2))); \
+			else \
+				printf ("- "); \
+			if (!(temp2 % 0xF)) printf ("\n"); \
+		} \
+                } \
+        }
+#endif
+#else
+#define verboseU8Array(arr,len,sblock)
+#endif
diff -Naur wv-1.0.3-orig/wvConfig.c wv-1.0.3/wvConfig.c
--- wv-1.0.3-orig/wvConfig.c	2002-07-14 13:20:07.000000000 +0000
+++ wv-1.0.3/wvConfig.c	2005-10-02 23:35:16.000000000 +0000
@@ -2130,7 +2130,7 @@
 }
 
 static void
-startElement (void *userData, const XML_Char *name, const XML_Char **atts)
+wvStartElement (void *userData, const XML_Char *name, const XML_Char **atts)
 {
     unsigned int nAtts = 0;
     const XML_Char **p;
@@ -3094,7 +3094,7 @@
 }
 
 static void
-endElement (void *userData, const XML_Char *name)
+wvEndElement (void *userData, const XML_Char *name)
 {
     state_data *mydata = (state_data *) userData;
     unsigned int token_type;
@@ -3470,8 +3470,8 @@
 	memset(&hdl, 0, sizeof(hdl));
 
 	hdl.getEntity = _getEntity;
-	hdl.startElement = startElement;
-	hdl.endElement = endElement;
+	hdl.startElement = wvStartElement;
+	hdl.endElement = wvEndElement;
 	hdl.characters = charData;
 
 	if (myhandle->fp)
@@ -3514,7 +3514,7 @@
     size_t len;
 
     XML_SetUserData (parser, myhandle);
-    XML_SetElementHandler (parser, startElement, endElement);
+    XML_SetElementHandler (parser, wvStartElement, wvEndElement);
     XML_SetCharacterDataHandler (parser, charData);
 
     if (myhandle->fp == NULL)
